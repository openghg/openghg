
<!DOCTYPE html>

<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>openghg.analyse._scenario &#8212; OpenGHG 0+untagged.1.g87961f6.dirty documentation</title>
  
  
  
  <script data-cfasync="false">
    document.documentElement.dataset.mode = localStorage.getItem("mode") || "";
    document.documentElement.dataset.theme = localStorage.getItem("theme") || "light";
  </script>
  
  <!-- Loaded before other Sphinx assets -->
  <link href="../../../_static/styles/theme.css?digest=796348d33e8b1d947c94" rel="stylesheet">
<link href="../../../_static/styles/bootstrap.css?digest=796348d33e8b1d947c94" rel="stylesheet">
<link href="../../../_static/styles/pydata-sphinx-theme.css?digest=796348d33e8b1d947c94" rel="stylesheet">

  
  <link href="../../../_static/vendor/fontawesome/6.1.2/css/all.min.css?digest=796348d33e8b1d947c94" rel="stylesheet">
  <link rel="preload" as="font" type="font/woff2" crossorigin href="../../../_static/vendor/fontawesome/6.1.2/webfonts/fa-solid-900.woff2">
<link rel="preload" as="font" type="font/woff2" crossorigin href="../../../_static/vendor/fontawesome/6.1.2/webfonts/fa-brands-400.woff2">
<link rel="preload" as="font" type="font/woff2" crossorigin href="../../../_static/vendor/fontawesome/6.1.2/webfonts/fa-regular-400.woff2">

    <link rel="stylesheet" type="text/css" href="../../../_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="../../../_static/mystnb.4510f1fc1dee50b3e5859aac5469c37c29e427902b24a333a5f9fcb2f0b3ac41.css" />
    <link rel="stylesheet" type="text/css" href="../../../_static/togglebutton.css" />
    <link rel="stylesheet" type="text/css" href="../../../_static/custom.css" />
  
  <!-- Pre-loaded scripts that we'll load fully later -->
  <link rel="preload" as="script" href="../../../_static/scripts/bootstrap.js?digest=796348d33e8b1d947c94">
<link rel="preload" as="script" href="../../../_static/scripts/pydata-sphinx-theme.js?digest=796348d33e8b1d947c94">

    <script data-url_root="../../../" id="documentation_options" src="../../../_static/documentation_options.js"></script>
    <script src="../../../_static/jquery.js"></script>
    <script src="../../../_static/underscore.js"></script>
    <script src="../../../_static/_sphinx_javascript_frameworks_compat.js"></script>
    <script src="../../../_static/doctools.js"></script>
    <script src="../../../_static/sphinx_highlight.js"></script>
    <script>let toggleHintShow = 'Click to show';</script>
    <script>let toggleHintHide = 'Click to hide';</script>
    <script>let toggleOpenOnPrint = 'true';</script>
    <script src="../../../_static/togglebutton.js"></script>
    <script>var togglebuttonSelector = '.toggle, .admonition.dropdown';</script>
    <script>DOCUMENTATION_OPTIONS.pagename = '_modules/openghg/analyse/_scenario';</script>
    <script src="../../../_static/custom.js"></script>
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <meta name="docsearch:language" content="en">
  </head>
  
  
  <body data-spy="scroll" data-target="#bd-toc-nav" data-offset="180" data-default-mode="">

  
  
  <a class="skip-link" href="#main-content">Skip to main content</a>

  
  <input type="checkbox" class="sidebar-toggle" name="__primary" id="__primary">
  <label class="overlay overlay-primary" for="__primary"></label>

  
  <input type="checkbox" class="sidebar-toggle" name="__secondary" id="__secondary">
  <label class="overlay overlay-secondary" for="__secondary"></label>

  
  <div class="search-button__wrapper">
    <div class="search-button__overlay"></div>
    <div class="search-button__search-container">
      
<form class="bd-search d-flex align-items-center" action="../../../search.html" method="get">
  <i class="fa-solid fa-magnifying-glass"></i>
  <input type="search" class="form-control" name="q" id="search-input" placeholder="Search the docs ..." aria-label="Search the docs ..." autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false">
  <span class="search-button__kbd-shortcut"><kbd class="kbd-shortcut__modifier">Ctrl</kbd>+<kbd>K</kbd></span>
</form>
    </div>
  </div>

  
  <nav class="bd-header navbar navbar-expand-lg bd-navbar" id="navbar-main"><div class="bd-header__inner bd-page-width">
  <label class="sidebar-toggle primary-toggle" for="__primary">
      <span class="fa-solid fa-bars"></span>
  </label>
  <div id="navbar-start">
    
    
  


<a class="navbar-brand logo" href="../../../index.html">

  
  
  
  
  
  
  

  
  
    <p class="title logo__title">OpenGHG 0+untagged.1.g87961f6.dirty documentation</p>
  
</a>
    
  </div>

  
  <div class="col-lg-9 navbar-header-items">
    <div id="navbar-center" class="mr-auto">
      
      <div class="navbar-center-item">
        <nav class="navbar-nav">
    <p class="sidebar-header-items__title" role="heading" aria-level="1" aria-label="Site Navigation">
        Site Navigation
    </p>
    <ul id="navbar-main-elements" class="navbar-nav">
        
                    <li class="nav-item">
                      <a class="nav-link nav-internal" href="../../../install.html">
                        Installation
                      </a>
                    </li>
                

                    <li class="nav-item">
                      <a class="nav-link nav-internal" href="../../../tutorials/index.html">
                        Tutorials
                      </a>
                    </li>
                

                    <li class="nav-item">
                      <a class="nav-link nav-internal" href="../../../api/index.html">
                        User API
                      </a>
                    </li>
                

                    <li class="nav-item">
                      <a class="nav-link nav-internal" href="../../../development/index_devel.html">
                        Development
                      </a>
                    </li>
                

                    <li class="nav-item">
                      <a class="nav-link nav-internal" href="../../../api/index_devapi.html">
                        Developer API
                      </a>
                    </li>
                
            <div class="nav-item dropdown">
                <button class="btn dropdown-toggle nav-item" type="button" data-toggle="dropdown" aria-haspopup="true" aria-expanded="false">
                    More
                </button>
                <div class="dropdown-menu">
                    
                    <li class="nav-item">
                      <a class="nav-link nav-internal" href="../../../whatsnew/index.html">
                        Whatâ€™s new
                      </a>
                    </li>
                
                </div>
            </div>
            
    </ul>
</nav>
      </div>
      
    </div>

    <div id="navbar-end">
      
        <div class="navbar-end-item navbar-persistent--container">
          
<button class="btn btn-sm navbar-btn search-button search-button__button" title="Search" aria-label="Search" data-toggle="tooltip">
  <i class="fa-solid fa-magnifying-glass"></i>
</button>
        </div>
      
      
      <div class="navbar-end-item">
        <button class="theme-switch-button btn btn-sm btn-outline-primary navbar-btn rounded-circle" title="light/dark" aria-label="light/dark" data-toggle="tooltip">
    <span class="theme-switch" data-mode="light"><i class="fa-solid fa-sun"></i></span>
    <span class="theme-switch" data-mode="dark"><i class="fa-solid fa-moon"></i></span>
    <span class="theme-switch" data-mode="auto"><i class="fa-solid fa-circle-half-stroke"></i></span>
</button>
      </div>
      
      <div class="navbar-end-item">
        <ul id="navbar-icon-links" class="navbar-nav" aria-label="Icon Links">
      </ul>
      </div>
      
    </div>
  </div>


  
  
    <div class="navbar-persistent--mobile">
<button class="btn btn-sm navbar-btn search-button search-button__button" title="Search" aria-label="Search" data-toggle="tooltip">
  <i class="fa-solid fa-magnifying-glass"></i>
</button>
    </div>
  

  
  <label class="sidebar-toggle secondary-toggle" for="__secondary">
      <span class="fa-solid fa-outdent"></span>
  </label>
  

</div>
  </nav>
  

  <div class="bd-container">
    <div class="bd-container__inner bd-page-width">
      
      <div class="bd-sidebar-primary bd-sidebar hide-on-wide">
        
  
  <div class="sidebar-header-items sidebar-primary__section">
    
    
      <div class="sidebar-header-items__center">
      
      <div class="navbar-center-item">
        <nav class="navbar-nav">
    <p class="sidebar-header-items__title" role="heading" aria-level="1" aria-label="Site Navigation">
        Site Navigation
    </p>
    <ul id="navbar-main-elements" class="navbar-nav">
        
                    <li class="nav-item">
                      <a class="nav-link nav-internal" href="../../../install.html">
                        Installation
                      </a>
                    </li>
                

                    <li class="nav-item">
                      <a class="nav-link nav-internal" href="../../../tutorials/index.html">
                        Tutorials
                      </a>
                    </li>
                

                    <li class="nav-item">
                      <a class="nav-link nav-internal" href="../../../api/index.html">
                        User API
                      </a>
                    </li>
                

                    <li class="nav-item">
                      <a class="nav-link nav-internal" href="../../../development/index_devel.html">
                        Development
                      </a>
                    </li>
                

                    <li class="nav-item">
                      <a class="nav-link nav-internal" href="../../../api/index_devapi.html">
                        Developer API
                      </a>
                    </li>
                
            <div class="nav-item dropdown">
                <button class="btn dropdown-toggle nav-item" type="button" data-toggle="dropdown" aria-haspopup="true" aria-expanded="false">
                    More
                </button>
                <div class="dropdown-menu">
                    
                    <li class="nav-item">
                      <a class="nav-link nav-internal" href="../../../whatsnew/index.html">
                        Whatâ€™s new
                      </a>
                    </li>
                
                </div>
            </div>
            
    </ul>
</nav>
      </div>
      
      </div>
    

    
    
    <div class="sidebar-header-items__end">
      
      <div class="navbar-end-item">
        <button class="theme-switch-button btn btn-sm btn-outline-primary navbar-btn rounded-circle" title="light/dark" aria-label="light/dark" data-toggle="tooltip">
    <span class="theme-switch" data-mode="light"><i class="fa-solid fa-sun"></i></span>
    <span class="theme-switch" data-mode="dark"><i class="fa-solid fa-moon"></i></span>
    <span class="theme-switch" data-mode="auto"><i class="fa-solid fa-circle-half-stroke"></i></span>
</button>
      </div>
      
      <div class="navbar-end-item">
        <ul id="navbar-icon-links" class="navbar-nav" aria-label="Icon Links">
      </ul>
      </div>
      
    </div>
    
  </div>

  

  
  <div class="sidebar-end-items sidebar-primary__section">
    <div class="sidebar-end-items__item">
    </div>
  </div>

  
  <div id="rtd-footer-container"></div>

      </div>
      <main id="main-content" class="bd-main">
        
        
        <div class="bd-content">
          <div class="bd-article-container">
            
            <div class="bd-header-article">
                
            </div>
            
            
            <article class="bd-article" role="main">
              
  <h1>Source code for openghg.analyse._scenario</h1><div class="highlight"><pre>
<span></span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">The ModelScenario class allows users to collate related data sources and calculate</span>
<span class="sd">modelled output based on this data. The types of data currently included are:</span>
<span class="sd"> - Timeseries observation data (ObsData)</span>
<span class="sd"> - Fixed domain sensitivity maps known as footprints (FootprintData)</span>
<span class="sd"> - Fixed domain flux maps (FluxData) - multiple maps can be included and</span>
<span class="sd"> referenced by source name</span>
<span class="sd"> - Fixed domain vertical curtains at each boundary (BoundaryConditionsData)</span>

<span class="sd">A ModelScenario instance can be created by searching the object store manually</span>
<span class="sd">and providing these outputs:</span>
<span class="sd">&gt;&gt;&gt; obs = get_obs_surface(site, species, inlet, ...)</span>
<span class="sd">&gt;&gt;&gt; footprint = get_footprint(site, domain, inlet, ...)</span>
<span class="sd">&gt;&gt;&gt; flux = get_flux(species, source, domain, ...)</span>
<span class="sd">&gt;&gt;&gt; bc = get_bc(species, domain, bc_input, ...)</span>
<span class="sd">&gt;&gt;&gt; model = ModelScenario(obs=obs, footprint=footprint, flux=flux, bc=bc)</span>

<span class="sd">A ModelScenario instance can also be created using keywords to search the object store:</span>
<span class="sd">&gt;&gt;&gt; model = ModelScenario(site,</span>
<span class="sd">                          species,</span>
<span class="sd">                          inlet,</span>
<span class="sd">                          network,</span>
<span class="sd">                          domain,</span>
<span class="sd">                          sources=sources,</span>
<span class="sd">                          bc_input=bc_input,</span>
<span class="sd">                          start_date=start_date,</span>
<span class="sd">                          end_date=end_date)</span>

<span class="sd">A ModelScenario instance can also be initialised and then populated after creation:</span>
<span class="sd">&gt;&gt;&gt; model = ModelScenario()</span>
<span class="sd">&gt;&gt;&gt; model.add_obs(obs=obs)</span>
<span class="sd">&gt;&gt;&gt; model.add_footprint(site, inlet, domain, ...)</span>
<span class="sd">&gt;&gt;&gt; model.add_flux(species, domain, sources, ...)</span>
<span class="sd">&gt;&gt;&gt; model.add_bc(species, domain, bc_input, ...)</span>

<span class="sd">Once created, methods can be called on ModelScenario which will combine these</span>
<span class="sd">data sources and cache the outputs (if requested) to make for quicker calculation.</span>

<span class="sd">&gt;&gt;&gt; modelled_obs = model.calc_modelled_obs()</span>
<span class="sd">&gt;&gt;&gt; modelled_baseline = model.calc_modelled_baseline()</span>
<span class="sd">&gt;&gt;&gt; combined_data = model.footprints_data_merge()</span>

<span class="sd">If some input types needed for these operations are missing, the user will be alerted</span>
<span class="sd">on which data types are missing.</span>
<span class="sd">&quot;&quot;&quot;</span>

<span class="kn">import</span> <span class="nn">logging</span>
<span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">Any</span><span class="p">,</span> <span class="n">Dict</span><span class="p">,</span> <span class="n">List</span><span class="p">,</span> <span class="n">Literal</span><span class="p">,</span> <span class="n">Optional</span><span class="p">,</span> <span class="n">Sequence</span><span class="p">,</span> <span class="n">Tuple</span><span class="p">,</span> <span class="n">Union</span><span class="p">,</span> <span class="n">cast</span>

<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">from</span> <span class="nn">openghg.dataobjects</span> <span class="kn">import</span> <span class="n">BoundaryConditionsData</span><span class="p">,</span> <span class="n">FluxData</span><span class="p">,</span> <span class="n">FootprintData</span><span class="p">,</span> <span class="n">ObsData</span>
<span class="kn">from</span> <span class="nn">openghg.retrieve</span> <span class="kn">import</span> <span class="p">(</span>
    <span class="n">get_obs_surface</span><span class="p">,</span>
    <span class="n">get_bc</span><span class="p">,</span>
    <span class="n">get_flux</span><span class="p">,</span>
    <span class="n">get_footprint</span><span class="p">,</span>
    <span class="n">search_surface</span><span class="p">,</span>
    <span class="n">search_bc</span><span class="p">,</span>
    <span class="n">search_flux</span><span class="p">,</span>
    <span class="n">search_footprints</span><span class="p">,</span>
<span class="p">)</span>
<span class="kn">from</span> <span class="nn">openghg.util</span> <span class="kn">import</span> <span class="n">synonyms</span>
<span class="kn">from</span> <span class="nn">openghg.types</span> <span class="kn">import</span> <span class="n">SearchError</span>
<span class="kn">from</span> <span class="nn">pandas</span> <span class="kn">import</span> <span class="n">Timestamp</span>
<span class="kn">from</span> <span class="nn">xarray</span> <span class="kn">import</span> <span class="n">DataArray</span><span class="p">,</span> <span class="n">Dataset</span>

<span class="n">__all__</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;ModelScenario&quot;</span><span class="p">,</span> <span class="s2">&quot;combine_datasets&quot;</span><span class="p">,</span> <span class="s2">&quot;stack_datasets&quot;</span><span class="p">,</span> <span class="s2">&quot;calc_dim_resolution&quot;</span><span class="p">,</span> <span class="s2">&quot;match_dataset_dims&quot;</span><span class="p">]</span>


<span class="c1"># TODO: Really with the emissions, they shouldn&#39;t need to match against a domain</span>
<span class="c1"># We should be able to grab global/bigger area emissions and cut that down</span>
<span class="c1"># to whichever area our LPDM model covers.</span>

<span class="c1"># TODO: Add static methods for different ways of creating the class</span>
<span class="c1"># e.g. from_existing_data(), from_search(), empty() , ...</span>

<span class="n">ParamType</span> <span class="o">=</span> <span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]]],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]]]</span>
<span class="n">methodType</span> <span class="o">=</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Literal</span><span class="p">[</span><span class="s2">&quot;nearest&quot;</span><span class="p">,</span> <span class="s2">&quot;pad&quot;</span><span class="p">,</span> <span class="s2">&quot;ffill&quot;</span><span class="p">,</span> <span class="s2">&quot;backfill&quot;</span><span class="p">,</span> <span class="s2">&quot;bfill&quot;</span><span class="p">]]</span>


<span class="n">logger</span> <span class="o">=</span> <span class="n">logging</span><span class="o">.</span><span class="n">getLogger</span><span class="p">(</span><span class="s2">&quot;openghg.analyse&quot;</span><span class="p">)</span>
<span class="n">logger</span><span class="o">.</span><span class="n">setLevel</span><span class="p">(</span><span class="n">logging</span><span class="o">.</span><span class="n">DEBUG</span><span class="p">)</span>  <span class="c1"># Have to set level for logger as well as handler</span>


<div class="viewcode-block" id="ModelScenario"><a class="viewcode-back" href="../../../api/api_analyse.html#openghg.analyse.ModelScenario">[docs]</a><span class="k">class</span> <span class="nc">ModelScenario</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    This class stores together observation data with ancillary data and allows</span>
<span class="sd">    operations to be performed combining these inputs.</span>
<span class="sd">    &quot;&quot;&quot;</span>

<div class="viewcode-block" id="ModelScenario.__init__"><a class="viewcode-back" href="../../../api/api_analyse.html#openghg.analyse.ModelScenario.__init__">[docs]</a>    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">site</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">species</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">inlet</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">height</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">network</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">domain</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">model</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">metmodel</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">source</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">sources</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Sequence</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">bc_input</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">start_date</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Timestamp</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">end_date</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Timestamp</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">obs</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ObsData</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">footprint</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">FootprintData</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">flux</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">FluxData</span><span class="p">,</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">FluxData</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">bc</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">BoundaryConditionsData</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Create a ModelScenario instance based on a set of keywords to be</span>
<span class="sd">        or directly supplied objects. This can be created as an empty class to be</span>
<span class="sd">        populated.</span>

<span class="sd">        The keywords are related to observation, footprint and flux data</span>
<span class="sd">        which may be available within the object store. The combination of these supplied</span>
<span class="sd">        will be used to extract the relevant data. Related keywords are as follows:</span>
<span class="sd">         - Observation data: site, species, inlet, network, start_date, end_data</span>
<span class="sd">         - Footprint data: site, inlet, domain, model, metmodel, species, start_date, end_date</span>
<span class="sd">         - Flux data: species, sources, domain, start_date, end_date</span>

<span class="sd">        Args:</span>
<span class="sd">            site : Site code e.g. &quot;TAC&quot;</span>
<span class="sd">            species : Species code e.g. &quot;ch4&quot;</span>
<span class="sd">            inlet : Inlet value e.g. &quot;10m&quot;</span>
<span class="sd">            height: Alias for inlet.</span>
<span class="sd">            network : Network name e.g. &quot;AGAGE&quot;</span>
<span class="sd">            domain : Domain name e.g. &quot;EUROPE&quot;</span>
<span class="sd">            model : Model name used in creation of footprint e.g. &quot;NAME&quot;</span>
<span class="sd">            metmodel : Name of met model used in creation of footprint e.g. &quot;UKV&quot;</span>
<span class="sd">            sources : Emissions sources</span>
<span class="sd">            bc_input : Input keyword for boundary conditions e.g. &quot;mozart&quot; or &quot;cams&quot;</span>
<span class="sd">            start_date : Start of date range to use. Note for flux this may not be applied</span>
<span class="sd">            end_date : End of date range to use. Note for flux this may not be applied</span>
<span class="sd">            obs : Supply ObsData object directly (e.g. from get_obs...() functions)</span>
<span class="sd">            footprint : Supply FootprintData object directly (e.g. from get_footprint() function)</span>
<span class="sd">            flux : Supply FluxData object directly (e.g. from get_flux() function)</span>
<span class="sd">        Returns:</span>
<span class="sd">            None</span>

<span class="sd">            Sets up instance of class with associated values.</span>

<span class="sd">        TODO: For obs, footprint, flux should we also allow Dataset input and turn</span>
<span class="sd">        these into the appropriate class?</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">obs</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ObsData</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">footprint</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">FootprintData</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">fluxes</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">FluxData</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">bc</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">BoundaryConditionsData</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="k">if</span> <span class="n">species</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">species</span> <span class="o">=</span> <span class="n">synonyms</span><span class="p">(</span><span class="n">species</span><span class="p">)</span>

        <span class="c1"># Add observation data (directly or through keywords)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">add_obs</span><span class="p">(</span>
            <span class="n">site</span><span class="o">=</span><span class="n">site</span><span class="p">,</span>
            <span class="n">species</span><span class="o">=</span><span class="n">species</span><span class="p">,</span>
            <span class="n">inlet</span><span class="o">=</span><span class="n">inlet</span><span class="p">,</span>
            <span class="n">height</span><span class="o">=</span><span class="n">height</span><span class="p">,</span>
            <span class="n">network</span><span class="o">=</span><span class="n">network</span><span class="p">,</span>
            <span class="n">start_date</span><span class="o">=</span><span class="n">start_date</span><span class="p">,</span>
            <span class="n">end_date</span><span class="o">=</span><span class="n">end_date</span><span class="p">,</span>
            <span class="n">obs</span><span class="o">=</span><span class="n">obs</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="c1"># Make sure obs data is present, make sure inputs match to metadata</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">obs</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">obs_metadata</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">obs</span><span class="o">.</span><span class="n">metadata</span>
            <span class="n">site</span> <span class="o">=</span> <span class="n">obs_metadata</span><span class="p">[</span><span class="s2">&quot;site&quot;</span><span class="p">]</span>
            <span class="n">species</span> <span class="o">=</span> <span class="n">obs_metadata</span><span class="p">[</span><span class="s2">&quot;species&quot;</span><span class="p">]</span>
            <span class="n">inlet</span> <span class="o">=</span> <span class="n">obs_metadata</span><span class="p">[</span><span class="s2">&quot;inlet&quot;</span><span class="p">]</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Updating any inputs based on observation data&quot;</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;site: </span><span class="si">{</span><span class="n">site</span><span class="si">}</span><span class="s2">, species: </span><span class="si">{</span><span class="n">species</span><span class="si">}</span><span class="s2">, inlet: </span><span class="si">{</span><span class="n">inlet</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="c1"># Add footprint data (directly or through keywords)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">add_footprint</span><span class="p">(</span>
            <span class="n">site</span><span class="o">=</span><span class="n">site</span><span class="p">,</span>
            <span class="n">inlet</span><span class="o">=</span><span class="n">inlet</span><span class="p">,</span>
            <span class="n">height</span><span class="o">=</span><span class="n">height</span><span class="p">,</span>
            <span class="n">domain</span><span class="o">=</span><span class="n">domain</span><span class="p">,</span>
            <span class="n">model</span><span class="o">=</span><span class="n">model</span><span class="p">,</span>
            <span class="n">metmodel</span><span class="o">=</span><span class="n">metmodel</span><span class="p">,</span>
            <span class="n">start_date</span><span class="o">=</span><span class="n">start_date</span><span class="p">,</span>
            <span class="n">end_date</span><span class="o">=</span><span class="n">end_date</span><span class="p">,</span>
            <span class="n">species</span><span class="o">=</span><span class="n">species</span><span class="p">,</span>
            <span class="n">footprint</span><span class="o">=</span><span class="n">footprint</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="c1"># Add flux data (directly or through keywords)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">add_flux</span><span class="p">(</span>
            <span class="n">species</span><span class="o">=</span><span class="n">species</span><span class="p">,</span>
            <span class="n">domain</span><span class="o">=</span><span class="n">domain</span><span class="p">,</span>
            <span class="n">source</span><span class="o">=</span><span class="n">source</span><span class="p">,</span>
            <span class="n">sources</span><span class="o">=</span><span class="n">sources</span><span class="p">,</span>
            <span class="n">start_date</span><span class="o">=</span><span class="n">start_date</span><span class="p">,</span>
            <span class="n">end_date</span><span class="o">=</span><span class="n">end_date</span><span class="p">,</span>
            <span class="n">flux</span><span class="o">=</span><span class="n">flux</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="c1"># Add boundary conditions (directly or through keywords)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">add_bc</span><span class="p">(</span>
            <span class="n">species</span><span class="o">=</span><span class="n">species</span><span class="p">,</span>
            <span class="n">bc_input</span><span class="o">=</span><span class="n">bc_input</span><span class="p">,</span>
            <span class="n">domain</span><span class="o">=</span><span class="n">domain</span><span class="p">,</span>
            <span class="n">start_date</span><span class="o">=</span><span class="n">start_date</span><span class="p">,</span>
            <span class="n">end_date</span><span class="o">=</span><span class="n">end_date</span><span class="p">,</span>
            <span class="n">bc</span><span class="o">=</span><span class="n">bc</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="c1"># Initialise attributes used for caching</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">scenario</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Dataset</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">modelled_obs</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">DataArray</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">modelled_baseline</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">DataArray</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">flux_stacked</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Dataset</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span></div>

        <span class="c1"># TODO: Check species, site etc. values align between inputs?</span>

    <span class="k">def</span> <span class="nf">_get_data</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">keywords</span><span class="p">:</span> <span class="n">ParamType</span><span class="p">,</span> <span class="n">data_type</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Any</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Use appropriate get function to search for data in object store.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">get_functions</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s2">&quot;obs_surface&quot;</span><span class="p">:</span> <span class="n">get_obs_surface</span><span class="p">,</span>
            <span class="s2">&quot;footprint&quot;</span><span class="p">:</span> <span class="n">get_footprint</span><span class="p">,</span>
            <span class="s2">&quot;flux&quot;</span><span class="p">:</span> <span class="n">get_flux</span><span class="p">,</span>
            <span class="s2">&quot;boundary_conditions&quot;</span><span class="p">:</span> <span class="n">get_bc</span><span class="p">,</span>
        <span class="p">}</span>

        <span class="n">search_functions</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s2">&quot;obs_surface&quot;</span><span class="p">:</span> <span class="n">search_surface</span><span class="p">,</span>
            <span class="s2">&quot;footprint&quot;</span><span class="p">:</span> <span class="n">search_footprints</span><span class="p">,</span>
            <span class="s2">&quot;flux&quot;</span><span class="p">:</span> <span class="n">search_flux</span><span class="p">,</span>
            <span class="s2">&quot;boundary_conditions&quot;</span><span class="p">:</span> <span class="n">search_bc</span><span class="p">,</span>
        <span class="p">}</span>

        <span class="n">get_fn</span> <span class="o">=</span> <span class="n">get_functions</span><span class="p">[</span><span class="n">data_type</span><span class="p">]</span>
        <span class="n">search_fn</span> <span class="o">=</span> <span class="n">search_functions</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">data_type</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">keywords</span><span class="p">,</span> <span class="nb">dict</span><span class="p">):</span>
            <span class="n">keywords</span> <span class="o">=</span> <span class="p">[</span><span class="n">keywords</span><span class="p">]</span>

        <span class="n">num_checks</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">keywords</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">keyword_set</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">keywords</span><span class="p">):</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">data</span> <span class="o">=</span> <span class="n">get_fn</span><span class="p">(</span><span class="o">**</span><span class="n">keyword_set</span><span class="p">)</span>  <span class="c1"># type:ignore</span>
            <span class="k">except</span> <span class="p">(</span><span class="n">SearchError</span><span class="p">,</span> <span class="ne">AttributeError</span><span class="p">):</span>
                <span class="n">num</span> <span class="o">=</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span>
                <span class="k">if</span> <span class="n">num</span> <span class="o">==</span> <span class="n">num_checks</span><span class="p">:</span>
                    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Unable to add </span><span class="si">{</span><span class="n">data_type</span><span class="si">}</span><span class="s2"> data based on keywords supplied.&quot;</span><span class="p">)</span>
                    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot; Inputs - </span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>
                    <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">keyword_set</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot; </span><span class="si">{</span><span class="n">key</span><span class="si">}</span><span class="s2">: </span><span class="si">{</span><span class="n">value</span><span class="si">}</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">search_fn</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                        <span class="n">data_search</span> <span class="o">=</span> <span class="n">search_fn</span><span class="p">(</span><span class="o">**</span><span class="n">keyword_set</span><span class="p">)</span>  <span class="c1"># type:ignore</span>
                        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;---- Search results ---&quot;</span><span class="p">)</span>
                        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Number of results returned: </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">data_search</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                        <span class="nb">print</span><span class="p">(</span><span class="n">data_search</span><span class="p">)</span>
                        <span class="c1"># TODO: If we can determine how many results are returned from search</span>
                        <span class="c1"># we can use this to give better information about why no data has</span>
                        <span class="c1"># been found for these inputs.</span>
                <span class="n">data</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Adding </span><span class="si">{</span><span class="n">data_type</span><span class="si">}</span><span class="s2"> to model scenario&quot;</span><span class="p">)</span>
                <span class="k">break</span>

        <span class="k">return</span> <span class="n">data</span>

<div class="viewcode-block" id="ModelScenario.add_obs"><a class="viewcode-back" href="../../../api/api_analyse.html#openghg.analyse.ModelScenario.add_obs">[docs]</a>    <span class="k">def</span> <span class="nf">add_obs</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">site</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">species</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">inlet</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">height</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">network</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">start_date</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Timestamp</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">end_date</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Timestamp</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">obs</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ObsData</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Add observation data based on keywords or direct ObsData object.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">openghg.util</span> <span class="kn">import</span> <span class="n">clean_string</span><span class="p">,</span> <span class="n">format_inlet</span>

        <span class="c1"># Search for obs data based on keywords</span>
        <span class="k">if</span> <span class="n">site</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">obs</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">site</span> <span class="o">=</span> <span class="n">clean_string</span><span class="p">(</span><span class="n">site</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">height</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">inlet</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">inlet</span> <span class="o">=</span> <span class="n">height</span>
            <span class="n">inlet</span> <span class="o">=</span> <span class="n">clean_string</span><span class="p">(</span><span class="n">inlet</span><span class="p">)</span>
            <span class="n">inlet</span> <span class="o">=</span> <span class="n">format_inlet</span><span class="p">(</span><span class="n">inlet</span><span class="p">)</span>

            <span class="c1"># search for obs based on suitable keywords - site, species, inlet</span>
            <span class="n">obs_keywords</span> <span class="o">=</span> <span class="p">{</span>
                <span class="s2">&quot;site&quot;</span><span class="p">:</span> <span class="n">site</span><span class="p">,</span>
                <span class="s2">&quot;species&quot;</span><span class="p">:</span> <span class="n">species</span><span class="p">,</span>
                <span class="s2">&quot;inlet&quot;</span><span class="p">:</span> <span class="n">inlet</span><span class="p">,</span>
                <span class="s2">&quot;network&quot;</span><span class="p">:</span> <span class="n">network</span><span class="p">,</span>
                <span class="s2">&quot;start_date&quot;</span><span class="p">:</span> <span class="n">start_date</span><span class="p">,</span>
                <span class="s2">&quot;end_date&quot;</span><span class="p">:</span> <span class="n">end_date</span><span class="p">,</span>
            <span class="p">}</span>

            <span class="n">obs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_data</span><span class="p">(</span><span class="n">obs_keywords</span><span class="p">,</span> <span class="n">data_type</span><span class="o">=</span><span class="s2">&quot;obs_surface&quot;</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">obs</span> <span class="o">=</span> <span class="n">obs</span>

        <span class="c1"># Add keywords to class for convenience</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">obs</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">site</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">obs</span><span class="o">.</span><span class="n">metadata</span><span class="p">[</span><span class="s2">&quot;site&quot;</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">species</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">obs</span><span class="o">.</span><span class="n">metadata</span><span class="p">[</span><span class="s2">&quot;species&quot;</span><span class="p">]</span></div>

<div class="viewcode-block" id="ModelScenario.add_footprint"><a class="viewcode-back" href="../../../api/api_analyse.html#openghg.analyse.ModelScenario.add_footprint">[docs]</a>    <span class="k">def</span> <span class="nf">add_footprint</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">site</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">inlet</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">height</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">domain</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">model</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">metmodel</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">start_date</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Timestamp</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">end_date</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Timestamp</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">species</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">footprint</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">FootprintData</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Add footprint data based on keywords or direct FootprintData object.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">openghg.util</span> <span class="kn">import</span> <span class="n">clean_string</span><span class="p">,</span> <span class="n">format_inlet</span><span class="p">,</span> <span class="n">species_lifetime</span>

        <span class="c1"># Search for footprint data based on keywords</span>
        <span class="c1"># - site, domain, inlet (can extract from obs), model, metmodel</span>
        <span class="k">if</span> <span class="n">site</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">footprint</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">site</span> <span class="o">=</span> <span class="n">clean_string</span><span class="p">(</span><span class="n">site</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">inlet</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">obs</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">inlet</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">obs</span><span class="o">.</span><span class="n">metadata</span><span class="p">[</span><span class="s2">&quot;inlet&quot;</span><span class="p">]</span>
            <span class="k">elif</span> <span class="n">inlet</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">height</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">inlet</span> <span class="o">=</span> <span class="n">height</span>                        
                <span class="n">inlet</span> <span class="o">=</span> <span class="n">clean_string</span><span class="p">(</span><span class="n">inlet</span><span class="p">)</span>
                <span class="n">inlet</span> <span class="o">=</span> <span class="n">format_inlet</span><span class="p">(</span><span class="n">inlet</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">inlet</span> <span class="o">=</span> <span class="n">clean_string</span><span class="p">(</span><span class="n">inlet</span><span class="p">)</span>
                <span class="n">inlet</span> <span class="o">=</span> <span class="n">format_inlet</span><span class="p">(</span><span class="n">inlet</span><span class="p">)</span>

            <span class="c1"># TODO: Add case to deal with &quot;multiple&quot; inlets</span>
            <span class="k">if</span> <span class="n">inlet</span> <span class="o">==</span> <span class="s2">&quot;multiple&quot;</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="s2">&quot;Unable to deal with multiple inlets yet:</span><span class="se">\n</span><span class="s2"> Please change date range or specify a specific inlet&quot;</span>
                <span class="p">)</span>

            <span class="n">footprint_keywords</span> <span class="o">=</span> <span class="p">{</span>
                <span class="s2">&quot;site&quot;</span><span class="p">:</span> <span class="n">site</span><span class="p">,</span>
                <span class="s2">&quot;height&quot;</span><span class="p">:</span> <span class="n">inlet</span><span class="p">,</span>
                <span class="s2">&quot;inlet&quot;</span><span class="p">:</span> <span class="n">inlet</span><span class="p">,</span>
                <span class="s2">&quot;domain&quot;</span><span class="p">:</span> <span class="n">domain</span><span class="p">,</span>
                <span class="s2">&quot;model&quot;</span><span class="p">:</span> <span class="n">model</span><span class="p">,</span>  <span class="c1"># Not currently used in get_footprint - should be added</span>
                <span class="c1"># &quot;metmodel&quot;: metmodel,  # Should be added to inputs for get_footprint()</span>
                <span class="s2">&quot;start_date&quot;</span><span class="p">:</span> <span class="n">start_date</span><span class="p">,</span>
                <span class="s2">&quot;end_date&quot;</span><span class="p">:</span> <span class="n">end_date</span><span class="p">,</span>
            <span class="p">}</span>

            <span class="c1"># Check whether general inert footprint should be extracted (suitable for long-lived species)</span>
            <span class="c1"># or species specific footprint</span>
            <span class="c1">#  - needed for short-lived species (includes additional parameters for age of particles)</span>
            <span class="c1">#  - needed for carbon dioxide (include high time resolution footprint)</span>
            <span class="n">species_lifetime_value</span> <span class="o">=</span> <span class="n">species_lifetime</span><span class="p">(</span><span class="n">species</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">species_lifetime_value</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">species</span> <span class="o">==</span> <span class="s2">&quot;co2&quot;</span><span class="p">:</span>
                <span class="n">footprint_keywords</span><span class="p">[</span><span class="s2">&quot;species&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">species</span>

            <span class="n">footprint</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_data</span><span class="p">(</span><span class="n">footprint_keywords</span><span class="p">,</span> <span class="n">data_type</span><span class="o">=</span><span class="s2">&quot;footprint&quot;</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">footprint</span> <span class="o">=</span> <span class="n">footprint</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">footprint</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;site&quot;</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">site</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">footprint</span><span class="o">.</span><span class="n">metadata</span><span class="p">[</span><span class="s2">&quot;site&quot;</span><span class="p">]</span></div>

<div class="viewcode-block" id="ModelScenario.add_flux"><a class="viewcode-back" href="../../../api/api_analyse.html#openghg.analyse.ModelScenario.add_flux">[docs]</a>    <span class="k">def</span> <span class="nf">add_flux</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">species</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">domain</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">source</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">sources</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Sequence</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">start_date</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Timestamp</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">end_date</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Timestamp</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">flux</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">FluxData</span><span class="p">,</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">FluxData</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Add flux data based on keywords or direct FluxData object.</span>
<span class="sd">        Can add flux datasets for multiple sources.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">fluxes</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># Check current species in any flux data</span>
            <span class="k">if</span> <span class="n">species</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">current_flux_1</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">fluxes</span><span class="o">.</span><span class="n">values</span><span class="p">())[</span><span class="mi">0</span><span class="p">]</span>
                <span class="n">current_species</span> <span class="o">=</span> <span class="n">current_flux_1</span><span class="o">.</span><span class="n">metadata</span><span class="p">[</span><span class="s2">&quot;species&quot;</span><span class="p">]</span>
                <span class="k">if</span> <span class="n">species</span> <span class="o">!=</span> <span class="n">current_species</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                        <span class="sa">f</span><span class="s2">&quot;New data must match current species </span><span class="si">{</span><span class="n">current_species</span><span class="si">}</span><span class="s2"> in ModelScenario. Input value: </span><span class="si">{</span><span class="n">species</span><span class="si">}</span><span class="s2">&quot;</span>
                    <span class="p">)</span>

        <span class="k">if</span> <span class="n">species</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">flux</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">flux</span> <span class="o">=</span> <span class="p">{}</span>

            <span class="k">if</span> <span class="n">sources</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">source</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">sources</span> <span class="o">=</span> <span class="p">[</span><span class="n">source</span><span class="p">]</span>
            <span class="k">elif</span> <span class="n">sources</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">sources</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
                <span class="n">sources</span> <span class="o">=</span> <span class="p">[</span><span class="n">sources</span><span class="p">]</span>

            <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">sources</span><span class="p">:</span>
                <span class="n">flux_keywords_1</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;species&quot;</span><span class="p">:</span> <span class="n">species</span><span class="p">,</span> <span class="s2">&quot;source&quot;</span><span class="p">:</span> <span class="n">name</span><span class="p">,</span> <span class="s2">&quot;domain&quot;</span><span class="p">:</span> <span class="n">domain</span><span class="p">}</span>

                <span class="c1"># For CO2 we need additional emissions data before a start_date to</span>
                <span class="c1"># match to high time resolution footprints.</span>
                <span class="c1"># For now, just extract all data</span>
                <span class="k">if</span> <span class="n">species</span> <span class="o">==</span> <span class="s2">&quot;co2&quot;</span><span class="p">:</span>
                    <span class="n">flux_keywords</span> <span class="o">=</span> <span class="p">[</span><span class="n">flux_keywords_1</span><span class="p">]</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">flux_keywords_2</span> <span class="o">=</span> <span class="n">flux_keywords_1</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

                    <span class="n">flux_keywords_1</span><span class="p">[</span><span class="s2">&quot;start_date&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">start_date</span>
                    <span class="n">flux_keywords_1</span><span class="p">[</span><span class="s2">&quot;end_date&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">end_date</span>

                    <span class="n">flux_keywords</span> <span class="o">=</span> <span class="p">[</span><span class="n">flux_keywords_1</span><span class="p">,</span> <span class="n">flux_keywords_2</span><span class="p">]</span>

                <span class="c1"># TODO: Add something to allow for e.g. global domain or no domain</span>

                <span class="n">flux_source</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_data</span><span class="p">(</span><span class="n">flux_keywords</span><span class="p">,</span> <span class="n">data_type</span><span class="o">=</span><span class="s2">&quot;flux&quot;</span><span class="p">)</span>
                <span class="c1"># TODO: May need to update this check if flux_source is empty FluxData() object</span>
                <span class="k">if</span> <span class="n">flux_source</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">flux</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">flux_source</span>

        <span class="k">elif</span> <span class="n">flux</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">flux</span><span class="p">,</span> <span class="nb">dict</span><span class="p">):</span>
                <span class="n">name</span> <span class="o">=</span> <span class="n">flux</span><span class="o">.</span><span class="n">metadata</span><span class="p">[</span><span class="s2">&quot;source&quot;</span><span class="p">]</span>
                <span class="n">flux</span> <span class="o">=</span> <span class="p">{</span><span class="n">name</span><span class="p">:</span> <span class="n">flux</span><span class="p">}</span>

        <span class="c1"># TODO: Make this so flux.anthro can be called etc. - link in some way</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">fluxes</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">flux</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">fluxes</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">flux</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">fluxes</span> <span class="o">=</span> <span class="n">flux</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">fluxes</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;species&quot;</span><span class="p">):</span>
                <span class="n">flux_values</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">fluxes</span><span class="o">.</span><span class="n">values</span><span class="p">())</span>
                <span class="n">flux_1</span> <span class="o">=</span> <span class="n">flux_values</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">species</span> <span class="o">=</span> <span class="n">flux_1</span><span class="o">.</span><span class="n">metadata</span><span class="p">[</span><span class="s2">&quot;species&quot;</span><span class="p">]</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">flux_sources</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">fluxes</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span></div>

<div class="viewcode-block" id="ModelScenario.add_bc"><a class="viewcode-back" href="../../../api/api_analyse.html#openghg.analyse.ModelScenario.add_bc">[docs]</a>    <span class="k">def</span> <span class="nf">add_bc</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">species</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">bc_input</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">domain</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">start_date</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Timestamp</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">end_date</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Timestamp</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">bc</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">BoundaryConditionsData</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Add boundary conditions data based on keywords or direct BoundaryConditionsData object.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># Search for boundary conditions data based on keywords</span>
        <span class="c1"># - domain, species, bc_input</span>
        <span class="k">if</span> <span class="n">domain</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">bc</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>

            <span class="n">bc_keywords</span> <span class="o">=</span> <span class="p">{</span>
                <span class="s2">&quot;species&quot;</span><span class="p">:</span> <span class="n">species</span><span class="p">,</span>
                <span class="s2">&quot;domain&quot;</span><span class="p">:</span> <span class="n">domain</span><span class="p">,</span>
                <span class="s2">&quot;bc_input&quot;</span><span class="p">:</span> <span class="n">bc_input</span><span class="p">,</span>
                <span class="s2">&quot;start_date&quot;</span><span class="p">:</span> <span class="n">start_date</span><span class="p">,</span>
                <span class="s2">&quot;end_date&quot;</span><span class="p">:</span> <span class="n">end_date</span><span class="p">,</span>
                <span class="s2">&quot;species&quot;</span><span class="p">:</span> <span class="n">species</span><span class="p">,</span>
            <span class="p">}</span>

            <span class="n">bc</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_data</span><span class="p">(</span><span class="n">bc_keywords</span><span class="p">,</span> <span class="n">data_type</span><span class="o">=</span><span class="s2">&quot;boundary_conditions&quot;</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">bc</span> <span class="o">=</span> <span class="n">bc</span></div>

    <span class="k">def</span> <span class="nf">_check_data_is_present</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">need</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Sequence</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Check whether correct data types have been included. This should</span>
<span class="sd">        be used by functions to check whether they can perform the requested</span>
<span class="sd">        operation with the data types available.</span>

<span class="sd">        Args:</span>
<span class="sd">            need (list) : Names of objects needed for the function being called.</span>
<span class="sd">            Should be one or more of &quot;obs&quot;, &quot;footprint&quot;, &quot;fluxes&quot; (or &quot;flux&quot;)</span>

<span class="sd">        Returns:</span>
<span class="sd">            None</span>

<span class="sd">            Raises ValueError is necessary data is missing.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">need</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">need</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;obs&quot;</span><span class="p">,</span> <span class="s2">&quot;footprint&quot;</span><span class="p">]</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">need</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="n">need</span> <span class="o">=</span> <span class="p">[</span><span class="n">need</span><span class="p">]</span>

        <span class="n">need</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;fluxes&quot;</span> <span class="k">if</span> <span class="n">value</span> <span class="o">==</span> <span class="s2">&quot;flux&quot;</span> <span class="k">else</span> <span class="n">value</span> <span class="k">for</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">need</span><span class="p">]</span>  <span class="c1"># Make sure attributes match</span>
        <span class="n">missing</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">attr</span> <span class="ow">in</span> <span class="n">need</span><span class="p">:</span>
            <span class="n">value</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">attr</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">value</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">missing</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">attr</span><span class="p">)</span>

                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Must have </span><span class="si">{</span><span class="n">attr</span><span class="si">}</span><span class="s2"> data linked to this ModelScenario to run this function&quot;</span><span class="p">)</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Include this by using the add function, with appropriate inputs:&quot;</span><span class="p">)</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;  ModelScenario.add_</span><span class="si">{attr}</span><span class="s2">(...)&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">missing</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Missing necessary </span><span class="si">{</span><span class="s1">&#39; and &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">missing</span><span class="p">)</span><span class="si">}</span><span class="s2"> data.&quot;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_get_platform</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Find the platform for a site, if present.</span>

<span class="sd">        This will access the &quot;acrg_site_info.json&quot; file to find this information.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">openghg.util</span> <span class="kn">import</span> <span class="n">load_json</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="n">site</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">site</span>
            <span class="n">site_upper</span> <span class="o">=</span> <span class="n">site</span><span class="o">.</span><span class="n">upper</span><span class="p">()</span>
        <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">site_info</span> <span class="o">=</span> <span class="n">load_json</span><span class="p">(</span><span class="n">filename</span><span class="o">=</span><span class="s2">&quot;acrg_site_info.json&quot;</span><span class="p">)</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">site_details</span> <span class="o">=</span> <span class="n">site_info</span><span class="p">[</span><span class="n">site_upper</span><span class="p">]</span>
            <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
                <span class="k">return</span> <span class="kc">None</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">platform</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="n">site_details</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;platform&quot;</span><span class="p">)</span>
                <span class="k">return</span> <span class="n">platform</span>

    <span class="k">def</span> <span class="nf">_align_obs_footprint</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">resample_to</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;coarsest&quot;</span><span class="p">,</span> <span class="n">platform</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Slice and resample obs and footprint data to align along time</span>

<span class="sd">        This slices the date to the smallest time frame</span>
<span class="sd">        spanned by both the footprint and obs, using the sliced start date</span>
<span class="sd">        The time dimension is resampled based on the resample_to input using the mean.</span>
<span class="sd">        The resample_to options are:</span>
<span class="sd">         - &quot;coarsest&quot; - resample to the coarsest resolution between obs and footprints</span>
<span class="sd">         - &quot;obs&quot; - resample to observation data frequency</span>
<span class="sd">         - &quot;footprint&quot; - resample to footprint data frequency</span>
<span class="sd">         - a valid resample period e.g. &quot;2H&quot;</span>

<span class="sd">        Args:</span>
<span class="sd">            resample_to: Resample option to use: either data based or using a valid pandas resample period.</span>
<span class="sd">            platform: Observation platform used to decide whether to resample</span>

<span class="sd">        Returns:</span>
<span class="sd">            tuple: Two xarray.Dataset with aligned time dimensions</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">pandas</span> <span class="kn">import</span> <span class="n">Timedelta</span>

        <span class="c1"># Check data is present (not None) and cast to correct type</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_check_data_is_present</span><span class="p">(</span><span class="n">need</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;obs&quot;</span><span class="p">,</span> <span class="s2">&quot;footprint&quot;</span><span class="p">])</span>
        <span class="n">obs</span> <span class="o">=</span> <span class="n">cast</span><span class="p">(</span><span class="n">ObsData</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">obs</span><span class="p">)</span>
        <span class="n">footprint</span> <span class="o">=</span> <span class="n">cast</span><span class="p">(</span><span class="n">FootprintData</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">footprint</span><span class="p">)</span>

        <span class="n">obs_data</span> <span class="o">=</span> <span class="n">obs</span><span class="o">.</span><span class="n">data</span>
        <span class="n">footprint_data</span> <span class="o">=</span> <span class="n">footprint</span><span class="o">.</span><span class="n">data</span>

        <span class="n">resample_keyword_choices</span> <span class="o">=</span> <span class="p">(</span><span class="s2">&quot;obs&quot;</span><span class="p">,</span> <span class="s2">&quot;footprint&quot;</span><span class="p">,</span> <span class="s2">&quot;coarsest&quot;</span><span class="p">)</span>

        <span class="c1"># Check whether resample has been requested by specifying a specific period rather than a keyword</span>
        <span class="k">if</span> <span class="n">resample_to</span> <span class="ow">in</span> <span class="n">resample_keyword_choices</span><span class="p">:</span>
            <span class="n">force_resample</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">force_resample</span> <span class="o">=</span> <span class="kc">True</span>

        <span class="k">if</span> <span class="n">platform</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">platform</span> <span class="o">=</span> <span class="n">platform</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span>
            <span class="c1"># Do not apply resampling for &quot;satellite&quot; (but have re-included &quot;flask&quot; for now)</span>
            <span class="k">if</span> <span class="n">platform</span> <span class="o">==</span> <span class="s2">&quot;satellite&quot;</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">obs_data</span><span class="p">,</span> <span class="n">footprint_data</span>

        <span class="c1"># Whether sampling period is present or we need to try to infer this</span>
        <span class="n">infer_sampling_period</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="c1"># Get the period of measurements in time</span>
        <span class="n">obs_attributes</span> <span class="o">=</span> <span class="n">obs_data</span><span class="o">.</span><span class="n">attrs</span>
        <span class="k">if</span> <span class="s2">&quot;averaged_period&quot;</span> <span class="ow">in</span> <span class="n">obs_attributes</span><span class="p">:</span>
            <span class="n">obs_data_period_s</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">obs_attributes</span><span class="p">[</span><span class="s2">&quot;averaged_period&quot;</span><span class="p">])</span>
        <span class="k">elif</span> <span class="s2">&quot;sampling_period&quot;</span> <span class="ow">in</span> <span class="n">obs_attributes</span><span class="p">:</span>
            <span class="n">sampling_period</span> <span class="o">=</span> <span class="n">obs_attributes</span><span class="p">[</span><span class="s2">&quot;sampling_period&quot;</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">sampling_period</span> <span class="o">==</span> <span class="s2">&quot;NOT_SET&quot;</span><span class="p">:</span>
                <span class="n">infer_sampling_period</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">obs_data_period_s</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">sampling_period</span><span class="p">)</span>
            <span class="n">obs_data_period_s</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">obs_attributes</span><span class="p">[</span><span class="s2">&quot;sampling_period&quot;</span><span class="p">])</span>
        <span class="k">elif</span> <span class="s2">&quot;sampling_period_estimate&quot;</span> <span class="ow">in</span> <span class="n">obs_attributes</span><span class="p">:</span>
            <span class="n">estimate</span> <span class="o">=</span> <span class="n">obs_attributes</span><span class="p">[</span><span class="s2">&quot;sampling_period_estimate&quot;</span><span class="p">]</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;WARNING: Using estimated sampling period of </span><span class="si">{</span><span class="n">estimate</span><span class="si">}</span><span class="s2">s for observational data&quot;</span><span class="p">)</span>
            <span class="n">obs_data_period_s</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">estimate</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">infer_sampling_period</span> <span class="o">=</span> <span class="kc">True</span>

        <span class="k">if</span> <span class="n">infer_sampling_period</span><span class="p">:</span>
            <span class="c1"># Attempt to derive sampling period from frequency of data</span>
            <span class="n">obs_data_period_s</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nanmedian</span><span class="p">(</span>
                <span class="p">(</span><span class="n">obs_data</span><span class="o">.</span><span class="n">time</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span> <span class="o">-</span> <span class="n">obs_data</span><span class="o">.</span><span class="n">time</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span> <span class="o">/</span> <span class="mf">1e9</span>
            <span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s2">&quot;float32&quot;</span><span class="p">)</span>

            <span class="n">obs_data_period_s_min</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">obs_data</span><span class="o">.</span><span class="n">time</span><span class="o">.</span><span class="n">data</span><span class="p">)</span><span class="o">.</span><span class="n">min</span><span class="p">()</span> <span class="o">/</span> <span class="mf">1e9</span>
            <span class="n">obs_data_period_s_max</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">obs_data</span><span class="o">.</span><span class="n">time</span><span class="o">.</span><span class="n">data</span><span class="p">)</span><span class="o">.</span><span class="n">max</span><span class="p">()</span> <span class="o">/</span> <span class="mf">1e9</span>

            <span class="n">max_diff</span> <span class="o">=</span> <span class="p">(</span><span class="n">obs_data_period_s_max</span> <span class="o">-</span> <span class="n">obs_data_period_s_min</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">float</span><span class="p">)</span>

            <span class="c1"># Check if the periods differ by more than 1 second</span>
            <span class="k">if</span> <span class="n">max_diff</span> <span class="o">&gt;</span> <span class="mf">1.0</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Sample period can be not be derived from observations&quot;</span><span class="p">)</span>

        <span class="c1"># TODO: Check regularity of the data - will need this to decide is resampling</span>
        <span class="c1"># is appropriate or need to do checks on a per time point basis</span>

        <span class="n">obs_data_period_ns</span> <span class="o">=</span> <span class="n">obs_data_period_s</span> <span class="o">*</span> <span class="mf">1e9</span>
        <span class="n">obs_data_timeperiod</span> <span class="o">=</span> <span class="n">Timedelta</span><span class="p">(</span><span class="n">obs_data_period_ns</span><span class="p">,</span> <span class="n">unit</span><span class="o">=</span><span class="s2">&quot;ns&quot;</span><span class="p">)</span>

        <span class="c1"># Derive the footprints period from the frequency of the data</span>
        <span class="n">footprint_data_period_ns</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nanmedian</span><span class="p">(</span>
            <span class="p">(</span><span class="n">footprint_data</span><span class="o">.</span><span class="n">time</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span> <span class="o">-</span> <span class="n">footprint_data</span><span class="o">.</span><span class="n">time</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s2">&quot;int64&quot;</span><span class="p">)</span>
        <span class="p">)</span>
        <span class="n">footprint_data_timeperiod</span> <span class="o">=</span> <span class="n">Timedelta</span><span class="p">(</span><span class="n">footprint_data_period_ns</span><span class="p">,</span> <span class="n">unit</span><span class="o">=</span><span class="s2">&quot;ns&quot;</span><span class="p">)</span>

        <span class="c1"># If resample_to is set to &quot;coarsest&quot;, check whether &quot;obs&quot; or &quot;footprint&quot; have lower resolution</span>
        <span class="k">if</span> <span class="n">resample_to</span> <span class="o">==</span> <span class="s2">&quot;coarsest&quot;</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">obs_data_timeperiod</span> <span class="o">&gt;=</span> <span class="n">footprint_data_timeperiod</span><span class="p">:</span>
                <span class="n">resample_to</span> <span class="o">=</span> <span class="s2">&quot;obs&quot;</span>
            <span class="k">elif</span> <span class="n">obs_data_timeperiod</span> <span class="o">&lt;</span> <span class="n">footprint_data_timeperiod</span><span class="p">:</span>
                <span class="n">resample_to</span> <span class="o">=</span> <span class="s2">&quot;footprint&quot;</span>

        <span class="c1"># Here we want timezone naive Timestamps</span>
        <span class="c1"># Add sampling period to end date to make sure resample includes these values when matching</span>
        <span class="n">obs_startdate</span> <span class="o">=</span> <span class="n">Timestamp</span><span class="p">(</span><span class="n">obs_data</span><span class="o">.</span><span class="n">time</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="p">)</span>
        <span class="n">obs_enddate</span> <span class="o">=</span> <span class="n">Timestamp</span><span class="p">(</span><span class="n">obs_data</span><span class="o">.</span><span class="n">time</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="p">)</span> <span class="o">+</span> <span class="n">obs_data_timeperiod</span>
        <span class="n">footprint_startdate</span> <span class="o">=</span> <span class="n">Timestamp</span><span class="p">(</span><span class="n">footprint_data</span><span class="o">.</span><span class="n">time</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="p">)</span>
        <span class="n">footprint_enddate</span> <span class="o">=</span> <span class="n">Timestamp</span><span class="p">(</span><span class="n">footprint_data</span><span class="o">.</span><span class="n">time</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="p">)</span> <span class="o">+</span> <span class="n">footprint_data_timeperiod</span>

        <span class="n">start_date</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">obs_startdate</span><span class="p">,</span> <span class="n">footprint_startdate</span><span class="p">)</span>
        <span class="n">end_date</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">obs_enddate</span><span class="p">,</span> <span class="n">footprint_enddate</span><span class="p">)</span>

        <span class="c1"># Ensure lower range is covered for obs</span>
        <span class="n">start_obs_slice</span> <span class="o">=</span> <span class="n">start_date</span> <span class="o">-</span> <span class="n">Timedelta</span><span class="p">(</span><span class="s2">&quot;1ns&quot;</span><span class="p">)</span>
        <span class="c1"># Ensure extra buffer is added for footprint based on fp timeperiod.</span>
        <span class="c1"># This is to ensure footprint can be forward-filled to obs (in later steps)</span>
        <span class="n">start_footprint_slice</span> <span class="o">=</span> <span class="n">start_date</span> <span class="o">-</span> <span class="p">(</span><span class="n">footprint_data_timeperiod</span> <span class="o">-</span> <span class="n">Timedelta</span><span class="p">(</span><span class="s2">&quot;1ns&quot;</span><span class="p">))</span>
        <span class="c1"># Subtract very small time increment (1 nanosecond) to make this an exclusive selection</span>
        <span class="n">end_slice</span> <span class="o">=</span> <span class="n">end_date</span> <span class="o">-</span> <span class="n">Timedelta</span><span class="p">(</span><span class="s2">&quot;1ns&quot;</span><span class="p">)</span>

        <span class="n">obs_data</span> <span class="o">=</span> <span class="n">obs_data</span><span class="o">.</span><span class="n">sel</span><span class="p">(</span><span class="n">time</span><span class="o">=</span><span class="nb">slice</span><span class="p">(</span><span class="n">start_obs_slice</span><span class="p">,</span> <span class="n">end_slice</span><span class="p">))</span>
        <span class="n">footprint_data</span> <span class="o">=</span> <span class="n">footprint_data</span><span class="o">.</span><span class="n">sel</span><span class="p">(</span><span class="n">time</span><span class="o">=</span><span class="nb">slice</span><span class="p">(</span><span class="n">start_footprint_slice</span><span class="p">,</span> <span class="n">end_slice</span><span class="p">))</span>

        <span class="c1"># Only non satellite datasets with different periods need to be resampled</span>
        <span class="n">timeperiod_diff_s</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">obs_data_timeperiod</span> <span class="o">-</span> <span class="n">footprint_data_timeperiod</span><span class="p">)</span><span class="o">.</span><span class="n">total_seconds</span><span class="p">()</span>
        <span class="n">tolerance</span> <span class="o">=</span> <span class="mf">1e-9</span>  <span class="c1"># seconds</span>

        <span class="k">if</span> <span class="n">timeperiod_diff_s</span> <span class="o">&gt;=</span> <span class="n">tolerance</span> <span class="ow">or</span> <span class="n">force_resample</span><span class="p">:</span>
            <span class="n">base</span> <span class="o">=</span> <span class="n">start_date</span><span class="o">.</span><span class="n">hour</span> <span class="o">+</span> <span class="n">start_date</span><span class="o">.</span><span class="n">minute</span> <span class="o">/</span> <span class="mf">60.0</span> <span class="o">+</span> <span class="n">start_date</span><span class="o">.</span><span class="n">second</span> <span class="o">/</span> <span class="mf">3600.0</span>

            <span class="k">if</span> <span class="n">resample_to</span> <span class="o">==</span> <span class="s2">&quot;obs&quot;</span><span class="p">:</span>
                <span class="n">resample_period</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="nb">round</span><span class="p">(</span><span class="n">obs_data_timeperiod</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">timedelta64</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s2">&quot;h&quot;</span><span class="p">),</span> <span class="mi">5</span><span class="p">))</span> <span class="o">+</span> <span class="s2">&quot;H&quot;</span>
                <span class="n">footprint_data</span> <span class="o">=</span> <span class="n">footprint_data</span><span class="o">.</span><span class="n">resample</span><span class="p">(</span><span class="n">indexer</span><span class="o">=</span><span class="p">{</span><span class="s2">&quot;time&quot;</span><span class="p">:</span> <span class="n">resample_period</span><span class="p">},</span> <span class="n">base</span><span class="o">=</span><span class="n">base</span><span class="p">)</span><span class="o">.</span><span class="n">mean</span><span class="p">()</span>

            <span class="k">elif</span> <span class="n">resample_to</span> <span class="o">==</span> <span class="s2">&quot;footprint&quot;</span><span class="p">:</span>
                <span class="n">resample_period</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="nb">round</span><span class="p">(</span><span class="n">footprint_data_timeperiod</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">timedelta64</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s2">&quot;h&quot;</span><span class="p">),</span> <span class="mi">5</span><span class="p">))</span> <span class="o">+</span> <span class="s2">&quot;H&quot;</span>
                <span class="n">obs_data</span> <span class="o">=</span> <span class="n">obs_data</span><span class="o">.</span><span class="n">resample</span><span class="p">(</span><span class="n">indexer</span><span class="o">=</span><span class="p">{</span><span class="s2">&quot;time&quot;</span><span class="p">:</span> <span class="n">resample_period</span><span class="p">},</span> <span class="n">base</span><span class="o">=</span><span class="n">base</span><span class="p">)</span><span class="o">.</span><span class="n">mean</span><span class="p">()</span>

            <span class="k">else</span><span class="p">:</span>
                <span class="n">resample_period</span> <span class="o">=</span> <span class="n">resample_to</span>
                <span class="n">footprint_data</span> <span class="o">=</span> <span class="n">footprint_data</span><span class="o">.</span><span class="n">resample</span><span class="p">(</span><span class="n">indexer</span><span class="o">=</span><span class="p">{</span><span class="s2">&quot;time&quot;</span><span class="p">:</span> <span class="n">resample_period</span><span class="p">},</span> <span class="n">base</span><span class="o">=</span><span class="n">base</span><span class="p">)</span><span class="o">.</span><span class="n">mean</span><span class="p">()</span>
                <span class="n">obs_data</span> <span class="o">=</span> <span class="n">obs_data</span><span class="o">.</span><span class="n">resample</span><span class="p">(</span><span class="n">indexer</span><span class="o">=</span><span class="p">{</span><span class="s2">&quot;time&quot;</span><span class="p">:</span> <span class="n">resample_period</span><span class="p">},</span> <span class="n">base</span><span class="o">=</span><span class="n">base</span><span class="p">)</span><span class="o">.</span><span class="n">mean</span><span class="p">()</span>

        <span class="k">return</span> <span class="n">obs_data</span><span class="p">,</span> <span class="n">footprint_data</span>

<div class="viewcode-block" id="ModelScenario.combine_obs_footprint"><a class="viewcode-back" href="../../../api/api_analyse.html#openghg.analyse.ModelScenario.combine_obs_footprint">[docs]</a>    <span class="k">def</span> <span class="nf">combine_obs_footprint</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">resample_to</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;coarsest&quot;</span><span class="p">,</span>
        <span class="n">platform</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">cache</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="n">recalculate</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Dataset</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Combine observation and footprint data so these are on the same time</span>
<span class="sd">        axis. This will both slice and resample the data to align this axis.</span>

<span class="sd">        - Data is slices to smallest timeframe spanned by both footprint and obs</span>
<span class="sd">        - Data is resampled according to resample_to input and using the mean</span>
<span class="sd">        - Data is combined into one dataset</span>

<span class="sd">        Args:</span>
<span class="sd">            resample_to: Resample option to use for averaging:</span>
<span class="sd">                          - either one of [&quot;coarsest&quot;, &quot;obs&quot;, &quot;footprint&quot;] to match to the datasets</span>
<span class="sd">                          - or using a valid pandas resample period e.g. &quot;2H&quot;.</span>
<span class="sd">                         Default = &quot;coarsest&quot;.</span>
<span class="sd">            platform: Observation platform used to decide whether to resample</span>
<span class="sd">            cache: Cache this data after calculation. Default = True.</span>

<span class="sd">        Returns:</span>
<span class="sd">            xarray.Dataset: Combined dataset aligned along the time dimension</span>

<span class="sd">            If cache is True:</span>
<span class="sd">                This data will be also be cached as the ModelScenario.scenario attribute.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_check_data_is_present</span><span class="p">(</span><span class="n">need</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;obs&quot;</span><span class="p">,</span> <span class="s2">&quot;footprint&quot;</span><span class="p">])</span>
        <span class="n">obs</span> <span class="o">=</span> <span class="n">cast</span><span class="p">(</span><span class="n">ObsData</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">obs</span><span class="p">)</span>
        <span class="n">footprint</span> <span class="o">=</span> <span class="n">cast</span><span class="p">(</span><span class="n">FootprintData</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">footprint</span><span class="p">)</span>

        <span class="c1"># Return any matching cached data</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">scenario</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">recalculate</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">scenario</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="s2">&quot;resample_to&quot;</span><span class="p">]</span> <span class="o">==</span> <span class="n">resample_to</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">scenario</span>

        <span class="c1"># As we&#39;re not processing any satellite data yet just set tolerance to None</span>
        <span class="n">tolerance</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="n">platform</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">platform</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_platform</span><span class="p">()</span>

        <span class="c1"># Align and merge the observation and footprint Datasets</span>
        <span class="n">aligned_obs</span><span class="p">,</span> <span class="n">aligned_footprint</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_align_obs_footprint</span><span class="p">(</span><span class="n">resample_to</span><span class="o">=</span><span class="n">resample_to</span><span class="p">,</span> <span class="n">platform</span><span class="o">=</span><span class="n">platform</span><span class="p">)</span>
        <span class="n">combined_dataset</span> <span class="o">=</span> <span class="n">combine_datasets</span><span class="p">(</span>
            <span class="n">dataset_A</span><span class="o">=</span><span class="n">aligned_obs</span><span class="p">,</span> <span class="n">dataset_B</span><span class="o">=</span><span class="n">aligned_footprint</span><span class="p">,</span> <span class="n">tolerance</span><span class="o">=</span><span class="n">tolerance</span>
        <span class="p">)</span>

        <span class="c1"># Transpose to keep time in the last dimension position in case it has been moved in resample</span>
        <span class="n">combined_dataset</span> <span class="o">=</span> <span class="n">combined_dataset</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="o">...</span><span class="p">,</span> <span class="s2">&quot;time&quot;</span><span class="p">)</span>

        <span class="c1"># Save the observation data units</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">mf</span> <span class="o">=</span> <span class="n">obs</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;mf&quot;</span><span class="p">]</span>
            <span class="n">units</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">float</span><span class="p">]</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">mf</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="s2">&quot;units&quot;</span><span class="p">])</span>
        <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
            <span class="n">units</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">AttributeError</span><span class="p">(</span><span class="s2">&quot;Unable to read mf attribute from observation data.&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">units</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">combined_dataset</span><span class="o">.</span><span class="n">update</span><span class="p">({</span><span class="s2">&quot;fp&quot;</span><span class="p">:</span> <span class="p">(</span><span class="n">combined_dataset</span><span class="o">.</span><span class="n">fp</span><span class="o">.</span><span class="n">dims</span><span class="p">,</span> <span class="p">(</span><span class="n">combined_dataset</span><span class="p">[</span><span class="s2">&quot;fp&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">data</span> <span class="o">/</span> <span class="n">units</span><span class="p">))})</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">species</span> <span class="o">==</span> <span class="s2">&quot;co2&quot;</span><span class="p">:</span>
                <span class="n">combined_dataset</span><span class="o">.</span><span class="n">update</span><span class="p">(</span>
                    <span class="p">{</span>
                        <span class="s2">&quot;fp_HiTRes&quot;</span><span class="p">:</span> <span class="p">(</span>
                            <span class="n">combined_dataset</span><span class="o">.</span><span class="n">fp_HiTRes</span><span class="o">.</span><span class="n">dims</span><span class="p">,</span>
                            <span class="p">(</span><span class="n">combined_dataset</span><span class="o">.</span><span class="n">fp_HiTRes</span><span class="o">.</span><span class="n">data</span> <span class="o">/</span> <span class="n">units</span><span class="p">),</span>
                        <span class="p">)</span>
                    <span class="p">}</span>
                <span class="p">)</span>

        <span class="n">attributes</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">attributes_obs</span> <span class="o">=</span> <span class="n">obs</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">attrs</span>
        <span class="n">attributes_footprint</span> <span class="o">=</span> <span class="n">footprint</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">attrs</span>
        <span class="n">attributes</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">attributes_footprint</span><span class="p">)</span>
        <span class="n">attributes</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">attributes_obs</span><span class="p">)</span>

        <span class="n">attributes</span><span class="p">[</span><span class="s2">&quot;resample_to&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">resample_to</span>

        <span class="n">combined_dataset</span><span class="o">.</span><span class="n">attrs</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">attributes</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">cache</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">scenario</span> <span class="o">=</span> <span class="n">combined_dataset</span>

        <span class="k">return</span> <span class="n">combined_dataset</span></div>

    <span class="k">def</span> <span class="nf">_clean_sources_input</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sources</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">List</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Check sources input and make sure this is a list. If None, this will extract</span>
<span class="sd">        all sources from self.fluxes.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_check_data_is_present</span><span class="p">(</span><span class="n">need</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;fluxes&quot;</span><span class="p">])</span>
        <span class="n">flux_dict</span> <span class="o">=</span> <span class="n">cast</span><span class="p">(</span><span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">FluxData</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">fluxes</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">sources</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">sources</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">flux_dict</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">sources</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="n">sources</span> <span class="o">=</span> <span class="p">[</span><span class="n">sources</span><span class="p">]</span>

        <span class="k">return</span> <span class="n">sources</span>

<div class="viewcode-block" id="ModelScenario.combine_flux_sources"><a class="viewcode-back" href="../../../api/api_analyse.html#openghg.analyse.ModelScenario.combine_flux_sources">[docs]</a>    <span class="k">def</span> <span class="nf">combine_flux_sources</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">sources</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">List</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">cache</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span> <span class="n">recalculate</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Dataset</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Combine together flux sources on the time dimension. This will align to</span>
<span class="sd">        the time of the highest frequency flux source both for time range and frequency.</span>

<span class="sd">        Args:</span>
<span class="sd">            sources : Names of sources to combine. Should already be attached to ModelScenario.</span>
<span class="sd">            cache : Cache this data after calculation. Default = True</span>

<span class="sd">        Returns:</span>
<span class="sd">            Dataset: All flux sources stacked on the time dimension.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_check_data_is_present</span><span class="p">(</span><span class="n">need</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;fluxes&quot;</span><span class="p">])</span>
        <span class="n">flux_dict</span> <span class="o">=</span> <span class="n">cast</span><span class="p">(</span><span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">FluxData</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">fluxes</span><span class="p">)</span>

        <span class="n">time_dim</span> <span class="o">=</span> <span class="s2">&quot;time&quot;</span>

        <span class="n">sources</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_clean_sources_input</span><span class="p">(</span><span class="n">sources</span><span class="p">)</span>
        <span class="n">sources_str</span> <span class="o">=</span> <span class="s2">&quot;, &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">sources</span><span class="p">)</span>

        <span class="c1"># Return any matching cached data</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">flux_stacked</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">recalculate</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">flux_stacked</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="s2">&quot;sources&quot;</span><span class="p">]</span> <span class="o">==</span> <span class="n">sources_str</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">flux_stacked</span>

        <span class="n">flux_datasets</span> <span class="o">=</span> <span class="p">[</span><span class="n">flux_dict</span><span class="p">[</span><span class="n">source</span><span class="p">]</span><span class="o">.</span><span class="n">data</span> <span class="k">for</span> <span class="n">source</span> <span class="ow">in</span> <span class="n">sources</span><span class="p">]</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">sources</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">flux_datasets</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

        <span class="c1"># Make sure other dimensions than time are aligned between flux datasets</span>
        <span class="c1"># - expects values to be closely aligned so only allows for a small floating point tolerance</span>
        <span class="n">dims</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">flux_datasets</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">dims</span><span class="p">)</span>
        <span class="n">dims</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="s2">&quot;time&quot;</span><span class="p">)</span>
        <span class="n">flux_datasets</span> <span class="o">=</span> <span class="n">match_dataset_dims</span><span class="p">(</span><span class="n">flux_datasets</span><span class="p">,</span> <span class="n">dims</span><span class="o">=</span><span class="n">dims</span><span class="p">)</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="n">flux_stacked</span> <span class="o">=</span> <span class="n">stack_datasets</span><span class="p">(</span><span class="n">flux_datasets</span><span class="p">,</span> <span class="n">dim</span><span class="o">=</span><span class="n">time_dim</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s2">&quot;ffill&quot;</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Unable to combine flux data for sources: </span><span class="si">{</span><span class="n">sources_str</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">cache</span><span class="p">:</span>
            <span class="n">flux_stacked</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="s2">&quot;sources&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">sources_str</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">flux_stacked</span> <span class="o">=</span> <span class="n">flux_stacked</span>

        <span class="k">return</span> <span class="n">flux_stacked</span></div>

    <span class="k">def</span> <span class="nf">_check_footprint_resample</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">resample_to</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Dataset</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Check whether footprint needs resampling based on resample_to input.</span>
<span class="sd">        Ignores resample_to keywords of (&quot;coarsest&quot;, &quot;obs&quot;, &quot;footprint&quot;) as this is</span>
<span class="sd">        for comparison with observation data but uses pandas frequencies to resample.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">footprint</span> <span class="o">=</span> <span class="n">cast</span><span class="p">(</span><span class="n">FootprintData</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">footprint</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">resample_to</span> <span class="ow">in</span> <span class="p">(</span><span class="s2">&quot;coarsest&quot;</span><span class="p">,</span> <span class="s2">&quot;obs&quot;</span><span class="p">,</span> <span class="s2">&quot;footprint&quot;</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">footprint</span><span class="o">.</span><span class="n">data</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">footprint_data</span> <span class="o">=</span> <span class="n">footprint</span><span class="o">.</span><span class="n">data</span>
            <span class="n">time</span> <span class="o">=</span> <span class="n">footprint_data</span><span class="p">[</span><span class="s2">&quot;time&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span>
            <span class="n">start_date</span> <span class="o">=</span> <span class="n">Timestamp</span><span class="p">(</span><span class="n">time</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
            <span class="n">base</span> <span class="o">=</span> <span class="n">start_date</span><span class="o">.</span><span class="n">hour</span> <span class="o">+</span> <span class="n">start_date</span><span class="o">.</span><span class="n">minute</span> <span class="o">/</span> <span class="mf">60.0</span> <span class="o">+</span> <span class="n">start_date</span><span class="o">.</span><span class="n">second</span> <span class="o">/</span> <span class="mf">3600.0</span>
            <span class="n">footprint_data</span> <span class="o">=</span> <span class="n">footprint_data</span><span class="o">.</span><span class="n">resample</span><span class="p">(</span><span class="n">indexer</span><span class="o">=</span><span class="p">{</span><span class="s2">&quot;time&quot;</span><span class="p">:</span> <span class="n">resample_to</span><span class="p">},</span> <span class="n">base</span><span class="o">=</span><span class="n">base</span><span class="p">)</span><span class="o">.</span><span class="n">mean</span><span class="p">()</span>
            <span class="k">return</span> <span class="n">footprint_data</span>

    <span class="k">def</span> <span class="nf">_param_setup</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">param</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;modelled_obs&quot;</span><span class="p">,</span>
        <span class="n">resample_to</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;coarsest&quot;</span><span class="p">,</span>
        <span class="n">platform</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">recalculate</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Decide if calculation is needed for input parameter and set up</span>
<span class="sd">        underlying parameters accordingly. This will populate the</span>
<span class="sd">        self.scenario attribute if not already present or if this needs</span>
<span class="sd">        to be recalculated.</span>

<span class="sd">        Args:</span>
<span class="sd">            param : Name of the parameter being calculated.</span>
<span class="sd">                    Should be one of &quot;modelled_obs&quot;, &quot;modelled_baseline&quot;</span>
<span class="sd">            resample_to: Resample option to use for averaging:</span>
<span class="sd">                          - either one of [&quot;coarsest&quot;, &quot;obs&quot;, &quot;footprint&quot;] to match to the datasets</span>
<span class="sd">                          - or using a valid pandas resample period e.g. &quot;2H&quot;.</span>
<span class="sd">                         Default = &quot;coarsest&quot;.</span>
<span class="sd">            platform: Observation platform used to decide whether to resample e.g. &quot;site&quot;, &quot;satellite&quot;.</span>
<span class="sd">            cache: Cache this data after calculation. Default = True.</span>
<span class="sd">            recalculate: Make sure to recalculate this data rather than return from cache. Default = False.</span>

<span class="sd">        Returns:</span>
<span class="sd">            bool: True if param should be calculated, False otherwise</span>

<span class="sd">            Populates details of ModelScenario.scenario to use in calculation.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="n">parameter</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">param</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Did not recognise input for </span><span class="si">{</span><span class="n">param</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="c1"># Check if cached modelled observations exist</span>
        <span class="c1"># if self.modelled_obs is None or recalculate:</span>
        <span class="k">if</span> <span class="n">parameter</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">recalculate</span><span class="p">:</span>
            <span class="c1"># Check if observations are present and use these for resampling</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">obs</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">combine_obs_footprint</span><span class="p">(</span>
                    <span class="n">resample_to</span><span class="p">,</span> <span class="n">platform</span><span class="o">=</span><span class="n">platform</span><span class="p">,</span> <span class="n">recalculate</span><span class="o">=</span><span class="n">recalculate</span><span class="p">,</span> <span class="n">cache</span><span class="o">=</span><span class="kc">True</span>
                <span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">scenario</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_check_footprint_resample</span><span class="p">(</span><span class="n">resample_to</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">obs</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="c1"># Check previous resample_to input for cached data</span>
                <span class="c1"># prev_resample_to = self.modelled_obs.attrs.get(&quot;resample_to&quot;)</span>
                <span class="n">prev_resample_to</span> <span class="o">=</span> <span class="n">parameter</span><span class="o">.</span><span class="n">attrs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;resample_to&quot;</span><span class="p">)</span>

                <span class="c1"># Check if this previous resample period matches input value</span>
                <span class="c1"># - if not (or explicit recalculation requested), recreate scenario</span>
                <span class="c1"># - if so return cached modelled observations</span>
                <span class="k">if</span> <span class="n">prev_resample_to</span> <span class="o">!=</span> <span class="n">resample_to</span> <span class="ow">or</span> <span class="n">recalculate</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">combine_obs_footprint</span><span class="p">(</span><span class="n">resample_to</span><span class="p">,</span> <span class="n">platform</span><span class="o">=</span><span class="n">platform</span><span class="p">,</span> <span class="n">cache</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="c1"># return self.modelled_obs</span>
                    <span class="k">return</span> <span class="kc">False</span>
            <span class="k">elif</span> <span class="n">recalculate</span><span class="p">:</span>
                <span class="c1"># Recalculate based on footprint data if obs not present</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">scenario</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_check_footprint_resample</span><span class="p">(</span><span class="n">resample_to</span><span class="p">)</span>

            <span class="c1"># TODO: Add check for matching sources and recalculate otherwise</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># Return cached modelled observations if explicit recalculation not requested</span>
                <span class="c1"># return self.modelled_obs</span>
                <span class="k">return</span> <span class="kc">False</span>

        <span class="k">return</span> <span class="kc">True</span>

<div class="viewcode-block" id="ModelScenario.calc_modelled_obs"><a class="viewcode-back" href="../../../api/api_analyse.html#openghg.analyse.ModelScenario.calc_modelled_obs">[docs]</a>    <span class="k">def</span> <span class="nf">calc_modelled_obs</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">sources</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">List</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">resample_to</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;coarsest&quot;</span><span class="p">,</span>
        <span class="n">platform</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">cache</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="n">recalculate</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">DataArray</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Calculate the modelled observation points based on site footprint and fluxes.</span>

<span class="sd">        The time points returned are dependent on the resample_to option chosen.</span>
<span class="sd">        If obs data is also linked to the ModelScenario instance, this will be used</span>
<span class="sd">        to derive the time points where appropriate.</span>

<span class="sd">        Args:</span>
<span class="sd">            sources: Sources to use for flux. All will be used and stacked if not specified.</span>
<span class="sd">            resample_to: Resample option to use for averaging:</span>
<span class="sd">                          - either one of [&quot;coarsest&quot;, &quot;obs&quot;, &quot;footprint&quot;] to match to the datasets</span>
<span class="sd">                          - or using a valid pandas resample period e.g. &quot;2H&quot;.</span>
<span class="sd">                         Default = &quot;coarsest&quot;.</span>
<span class="sd">            platform: Observation platform used to decide whether to resample e.g. &quot;site&quot;, &quot;satellite&quot;.</span>
<span class="sd">            cache: Cache this data after calculation. Default = True.</span>
<span class="sd">            recalculate: Make sure to recalculate this data rather than return from cache. Default = False.</span>

<span class="sd">        Returns:</span>
<span class="sd">            xarray.DataArray: Modelled observation values along the time axis</span>

<span class="sd">            If cache is True:</span>
<span class="sd">                This data will also be cached as the ModelScenario.modelled_obs attribute.</span>
<span class="sd">                The associated scenario data will be cached as the ModelScenario.scenario attribute.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_check_data_is_present</span><span class="p">(</span><span class="n">need</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;footprint&quot;</span><span class="p">,</span> <span class="s2">&quot;fluxes&quot;</span><span class="p">])</span>

        <span class="n">param_calculate</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_param_setup</span><span class="p">(</span>
            <span class="n">param</span><span class="o">=</span><span class="s2">&quot;modelled_obs&quot;</span><span class="p">,</span> <span class="n">resample_to</span><span class="o">=</span><span class="n">resample_to</span><span class="p">,</span> <span class="n">platform</span><span class="o">=</span><span class="n">platform</span><span class="p">,</span> <span class="n">recalculate</span><span class="o">=</span><span class="n">recalculate</span>
        <span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">param_calculate</span><span class="p">:</span>
            <span class="n">modelled_obs</span> <span class="o">=</span> <span class="n">cast</span><span class="p">(</span><span class="n">DataArray</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">modelled_obs</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">modelled_obs</span>

        <span class="c1"># Check species and use high time resolution steps if this is carbon dioxide</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">species</span> <span class="o">==</span> <span class="s2">&quot;co2&quot;</span><span class="p">:</span>
            <span class="n">modelled_obs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_calc_modelled_obs_HiTRes</span><span class="p">(</span>
                <span class="n">sources</span><span class="o">=</span><span class="n">sources</span><span class="p">,</span> <span class="n">output_TS</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">output_fpXflux</span><span class="o">=</span><span class="kc">False</span>
            <span class="p">)</span>
            <span class="n">name</span> <span class="o">=</span> <span class="s2">&quot;mf_mod_high_res&quot;</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">modelled_obs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_calc_modelled_obs_integrated</span><span class="p">(</span>
                <span class="n">sources</span><span class="o">=</span><span class="n">sources</span><span class="p">,</span> <span class="n">output_TS</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">output_fpXflux</span><span class="o">=</span><span class="kc">False</span>
            <span class="p">)</span>
            <span class="n">name</span> <span class="o">=</span> <span class="s2">&quot;mf_mod&quot;</span>

        <span class="n">modelled_obs</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="s2">&quot;resample_to&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">resample_to</span>
        <span class="n">modelled_obs</span> <span class="o">=</span> <span class="n">modelled_obs</span><span class="o">.</span><span class="n">rename</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>

        <span class="c1"># Cache output from calculations</span>
        <span class="k">if</span> <span class="n">cache</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Caching calculated data&quot;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">modelled_obs</span> <span class="o">=</span> <span class="n">modelled_obs</span>
            <span class="c1"># self.scenario[name] = modelled_obs</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">modelled_obs</span> <span class="o">=</span> <span class="kc">None</span>  <span class="c1"># Make sure this is reset and not cached</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">scenario</span> <span class="o">=</span> <span class="kc">None</span>  <span class="c1"># Reset this to None after calculation completed</span>

        <span class="k">return</span> <span class="n">modelled_obs</span></div>

    <span class="k">def</span> <span class="nf">_calc_modelled_obs_integrated</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">sources</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">List</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">output_TS</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="n">output_fpXflux</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Any</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Calculate modelled mole fraction timeseries using integrated footprints data.</span>

<span class="sd">        Args:</span>
<span class="sd">            sources : Flux sources to use for the calculation. By default this will use all available sources.</span>
<span class="sd">            output_TS : Whether to output the modelled mole fraction timeseries DataArray.</span>
<span class="sd">                       Default = True</span>
<span class="sd">            output_fpXflux : Whether to output the modelled flux map DataArray used to create</span>
<span class="sd">                            the timeseries. Default = False</span>

<span class="sd">        Returns:</span>
<span class="sd">            DataArray / DataArray :</span>
<span class="sd">                Modelled mole fraction timeseries, dimensions = (time)</span>
<span class="sd">                Modelled flux map, dimensions = (lat, lon, time)</span>

<span class="sd">            If one of output_TS and output_fpXflux are True:</span>
<span class="sd">                DataArray is returned for the respective output</span>

<span class="sd">            If both output_TS and output_fpXflux are both True:</span>
<span class="sd">                Both DataArrays are returned.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">scenario</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Combined data must have been defined before calling this function.&quot;</span><span class="p">)</span>

        <span class="n">scenario</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">scenario</span>
        <span class="n">flux</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">combine_flux_sources</span><span class="p">(</span><span class="n">sources</span><span class="p">)</span>
        <span class="n">scenario</span><span class="p">,</span> <span class="n">flux</span> <span class="o">=</span> <span class="n">match_dataset_dims</span><span class="p">([</span><span class="n">scenario</span><span class="p">,</span> <span class="n">flux</span><span class="p">],</span> <span class="n">dims</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;lat&quot;</span><span class="p">,</span> <span class="s2">&quot;lon&quot;</span><span class="p">])</span>

        <span class="n">flux</span> <span class="o">=</span> <span class="n">flux</span><span class="o">.</span><span class="n">reindex_like</span><span class="p">(</span><span class="n">scenario</span><span class="p">,</span> <span class="s2">&quot;ffill&quot;</span><span class="p">)</span>
        <span class="n">flux_modelled</span><span class="p">:</span> <span class="n">DataArray</span> <span class="o">=</span> <span class="n">scenario</span><span class="p">[</span><span class="s2">&quot;fp&quot;</span><span class="p">]</span> <span class="o">*</span> <span class="n">flux</span><span class="p">[</span><span class="s2">&quot;flux&quot;</span><span class="p">]</span>
        <span class="n">timeseries</span><span class="p">:</span> <span class="n">DataArray</span> <span class="o">=</span> <span class="n">flux_modelled</span><span class="o">.</span><span class="n">sum</span><span class="p">([</span><span class="s2">&quot;lat&quot;</span><span class="p">,</span> <span class="s2">&quot;lon&quot;</span><span class="p">])</span>

        <span class="c1"># TODO: Add details about units to output</span>

        <span class="k">if</span> <span class="n">output_TS</span> <span class="ow">and</span> <span class="n">output_fpXflux</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">timeseries</span><span class="p">,</span> <span class="n">flux_modelled</span>
        <span class="k">elif</span> <span class="n">output_TS</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">timeseries</span>
        <span class="k">elif</span> <span class="n">output_fpXflux</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">flux_modelled</span>

    <span class="k">def</span> <span class="nf">_calc_modelled_obs_HiTRes</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">sources</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">List</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">averaging</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">output_TS</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="n">output_fpXflux</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Any</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Calculate modelled mole fraction timeseries using high time resolution</span>
<span class="sd">        footprints data and emissions data. This is appropriate for time variable</span>
<span class="sd">        species reliant on high time resolution footprints such as carbon dioxide (co2).</span>

<span class="sd">        Args:</span>
<span class="sd">            sources : Flux sources to use for the calculation. By default this will use all available sources.</span>
<span class="sd">            averaging : Time resolution to use to average the time dimension. Default = None</span>
<span class="sd">            output_TS : Whether to output the modelled mole fraction timeseries DataArray.</span>
<span class="sd">                       Default = True</span>
<span class="sd">            output_fpXflux : Whether to output the modelled flux map DataArray used to create</span>
<span class="sd">                            the timeseries. Default = False</span>

<span class="sd">        Returns:</span>
<span class="sd">            DataArray / DataArray :</span>
<span class="sd">                Modelled mole fraction timeseries, dimensions = (time)</span>
<span class="sd">                Modelled flux map, dimensions = (lat, lon, time)</span>

<span class="sd">            If one of output_TS and output_fpXflux are True:</span>
<span class="sd">                DataArray is returned for the respective output</span>

<span class="sd">            If both output_TS and output_fpXflux are both True:</span>
<span class="sd">                Both DataArrays are returned.</span>

<span class="sd">        TODO: Low frequency flux values may need to be selected from the month before</span>
<span class="sd">        (currently selecting the same month).</span>
<span class="sd">        TODO: Indexing for low frequency flux should be checked to make sure this</span>
<span class="sd">        allows for crossing over the end of the year.</span>
<span class="sd">        TODO: Currently using pure dask arrays (based on Hannah&#39;s original code)</span>
<span class="sd">        but would be good to update this to add more pre-indexing using xarray</span>
<span class="sd">        and/or use dask as part of datasets.</span>
<span class="sd">        TODO: May want to update this to not rely on indexing when selecting</span>
<span class="sd">        the appropriate flux values. At the moment this solution has been chosen</span>
<span class="sd">        because selecting on a dimension, rather than indexing, can be *very* slow</span>
<span class="sd">        depending on the operations performed beforehand on the Dataset (e.g.</span>
<span class="sd">        resample and reindex)</span>
<span class="sd">        TODO: This code currently resamples the frequency to be regular. This will</span>
<span class="sd">        have no effect if the time frequency was already regular but this may</span>
<span class="sd">        not be what we want and may want to add extra code to remove any NaNs, if</span>
<span class="sd">        they are introduced or to find a way to remove this requirement.</span>
<span class="sd">        TODO: mypy having trouble with different types options and incompatible types,</span>
<span class="sd">        included as Any for now.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">math</span> <span class="kn">import</span> <span class="n">gcd</span>

        <span class="kn">import</span> <span class="nn">dask.array</span> <span class="k">as</span> <span class="nn">da</span>  <span class="c1"># type: ignore</span>
        <span class="kn">from</span> <span class="nn">pandas</span> <span class="kn">import</span> <span class="n">date_range</span>
        <span class="kn">from</span> <span class="nn">tqdm</span> <span class="kn">import</span> <span class="n">tqdm</span>

        <span class="c1"># TODO: Need to work out how this fits in with high time resolution method</span>
        <span class="c1"># Do we need to flag low resolution to use a different method? natural / anthro for example</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">scenario</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Combined data must have been defined before calling this function.&quot;</span><span class="p">)</span>

        <span class="n">fp_HiTRes</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">scenario</span><span class="o">.</span><span class="n">fp_HiTRes</span>
        <span class="n">flux_ds</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">combine_flux_sources</span><span class="p">(</span><span class="n">sources</span><span class="p">)</span>
        <span class="n">fp_HiTRes</span><span class="p">,</span> <span class="n">flux_ds</span> <span class="o">=</span> <span class="n">match_dataset_dims</span><span class="p">([</span><span class="n">fp_HiTRes</span><span class="p">,</span> <span class="n">flux_ds</span><span class="p">],</span> <span class="n">dims</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;lat&quot;</span><span class="p">,</span> <span class="s2">&quot;lon&quot;</span><span class="p">])</span>

        <span class="c1"># Make sure any NaN values are set to zero as this is a multiplicative and summing operation</span>
        <span class="n">fp_HiTRes</span> <span class="o">=</span> <span class="n">fp_HiTRes</span><span class="o">.</span><span class="n">fillna</span><span class="p">(</span><span class="mf">0.0</span><span class="p">)</span>
        <span class="n">flux_ds</span><span class="p">[</span><span class="s2">&quot;flux&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">flux_ds</span><span class="p">[</span><span class="s2">&quot;flux&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">fillna</span><span class="p">(</span><span class="mf">0.0</span><span class="p">)</span>

        <span class="c1"># Calculate time resolution for both the flux and footprints data</span>
        <span class="n">nanosecond_to_hour</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">/</span> <span class="p">(</span><span class="mf">1e9</span> <span class="o">*</span> <span class="mf">60.0</span> <span class="o">*</span> <span class="mf">60.0</span><span class="p">)</span>
        <span class="n">flux_res_H</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">flux_ds</span><span class="o">.</span><span class="n">time</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">dim</span><span class="o">=</span><span class="s2">&quot;time&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">values</span><span class="o">.</span><span class="n">mean</span><span class="p">()</span> <span class="o">*</span> <span class="n">nanosecond_to_hour</span><span class="p">)</span>
        <span class="n">fp_res_time_H</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">fp_HiTRes</span><span class="o">.</span><span class="n">time</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">dim</span><span class="o">=</span><span class="s2">&quot;time&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">values</span><span class="o">.</span><span class="n">mean</span><span class="p">()</span> <span class="o">*</span> <span class="n">nanosecond_to_hour</span><span class="p">)</span>

        <span class="n">fp_res_Hback_H</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">fp_HiTRes</span><span class="p">[</span><span class="s2">&quot;H_back&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">dim</span><span class="o">=</span><span class="s2">&quot;H_back&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">values</span><span class="o">.</span><span class="n">mean</span><span class="p">())</span>

        <span class="c1"># Define resolution on time dimension in number in hours</span>
        <span class="k">if</span> <span class="n">averaging</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">time_res_H</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">averaging</span><span class="p">)</span>
                <span class="n">time_resolution</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">time_res_H</span><span class="si">}</span><span class="s2">H&quot;</span>
            <span class="k">except</span> <span class="p">(</span><span class="ne">ValueError</span><span class="p">,</span> <span class="ne">TypeError</span><span class="p">):</span>
                <span class="n">time_res_H</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">averaging</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
                <span class="n">time_resolution</span> <span class="o">=</span> <span class="n">averaging</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># If not specified derive from time from combined dataset</span>
            <span class="n">time_res_H</span> <span class="o">=</span> <span class="n">fp_res_time_H</span>
            <span class="n">time_resolution</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">time_res_H</span><span class="si">}</span><span class="s2">H&quot;</span>

        <span class="c1"># Resample fp timeseries to match time resolution</span>
        <span class="k">if</span> <span class="n">fp_res_time_H</span> <span class="o">!=</span> <span class="n">time_res_H</span><span class="p">:</span>
            <span class="n">fp_HiTRes</span> <span class="o">=</span> <span class="n">fp_HiTRes</span><span class="o">.</span><span class="n">resample</span><span class="p">(</span><span class="n">time</span><span class="o">=</span><span class="n">time_resolution</span><span class="p">)</span><span class="o">.</span><span class="n">ffill</span><span class="p">()</span>

        <span class="c1"># Define resolution on high frequency dimension in number of hours</span>
        <span class="c1"># At the moment this is matched to the Hback dimension</span>
        <span class="n">time_hf_res_H</span> <span class="o">=</span> <span class="n">fp_res_Hback_H</span>

        <span class="c1"># Only allow for high frequency resolution &lt; 24 hours</span>
        <span class="k">if</span> <span class="n">time_hf_res_H</span> <span class="o">&gt;</span> <span class="mi">24</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;High frequency resolution must be &lt;= 24 hours. Current: </span><span class="si">{</span><span class="n">time_hf_res_H</span><span class="si">}</span><span class="s2">H&quot;</span><span class="p">)</span>
        <span class="k">elif</span> <span class="mi">24</span> <span class="o">%</span> <span class="n">time_hf_res_H</span> <span class="o">!=</span> <span class="mi">0</span> <span class="ow">or</span> <span class="mi">24</span> <span class="o">%</span> <span class="n">time_hf_res_H</span> <span class="o">!=</span> <span class="mf">0.0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;High frequency resolution must exactly divide into 24 hours. Current: </span><span class="si">{</span><span class="n">time_hf_res_H</span><span class="si">}</span><span class="s2">H&quot;</span>
            <span class="p">)</span>

        <span class="c1"># Find the greatest common denominator between time and high frequency resolutions.</span>
        <span class="c1"># This is needed to make sure suitable flux frequency is used to allow for indexing.</span>
        <span class="c1"># e.g. time: 1H; hf (high frequency): 2H, highest_res_H would be 1H</span>
        <span class="c1"># e.g. time: 2H; hf (high frequency): 3H, highest_res_H would be 1H</span>
        <span class="n">highest_res_H</span> <span class="o">=</span> <span class="n">gcd</span><span class="p">(</span><span class="n">time_res_H</span><span class="p">,</span> <span class="n">time_hf_res_H</span><span class="p">)</span>
        <span class="n">highest_resolution</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">highest_res_H</span><span class="si">}</span><span class="s2">H&quot;</span>

        <span class="c1"># create time array to loop through, with the required resolution</span>
        <span class="c1"># fp_HiTRes.time is the release time of particles into the model</span>
        <span class="n">time_array</span> <span class="o">=</span> <span class="n">fp_HiTRes</span><span class="p">[</span><span class="s2">&quot;time&quot;</span><span class="p">]</span>
        <span class="n">lat</span> <span class="o">=</span> <span class="n">fp_HiTRes</span><span class="p">[</span><span class="s2">&quot;lat&quot;</span><span class="p">]</span>
        <span class="n">lon</span> <span class="o">=</span> <span class="n">fp_HiTRes</span><span class="p">[</span><span class="s2">&quot;lon&quot;</span><span class="p">]</span>
        <span class="n">hback</span> <span class="o">=</span> <span class="n">fp_HiTRes</span><span class="p">[</span><span class="s2">&quot;H_back&quot;</span><span class="p">]</span>

        <span class="n">ntime</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">time_array</span><span class="p">)</span>
        <span class="n">nlat</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">lat</span><span class="p">)</span>
        <span class="n">nlon</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">lon</span><span class="p">)</span>
        <span class="c1"># nh_back = len(hback)</span>

        <span class="c1"># Define maximum hour back</span>
        <span class="n">max_h_back</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">hback</span><span class="o">.</span><span class="n">values</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>

        <span class="c1"># Define full range of dates to select from the flux input</span>
        <span class="n">date_start</span> <span class="o">=</span> <span class="n">time_array</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">date_start_back</span> <span class="o">=</span> <span class="n">date_start</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">timedelta64</span><span class="p">(</span><span class="n">max_h_back</span><span class="p">,</span> <span class="s2">&quot;h&quot;</span><span class="p">)</span>
        <span class="n">date_end</span> <span class="o">=</span> <span class="n">time_array</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">timedelta64</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s2">&quot;s&quot;</span><span class="p">)</span>

        <span class="n">start</span> <span class="o">=</span> <span class="p">{</span>
            <span class="n">dd</span><span class="p">:</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">datetime64</span><span class="p">(</span><span class="n">time_array</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="p">,</span> <span class="s2">&quot;h&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">object</span><span class="p">),</span> <span class="n">dd</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">dd</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;month&quot;</span><span class="p">,</span> <span class="s2">&quot;year&quot;</span><span class="p">]</span>
        <span class="p">}</span>

        <span class="c1"># Create times for matching to the flux</span>
        <span class="n">full_dates</span> <span class="o">=</span> <span class="n">date_range</span><span class="p">(</span>
            <span class="n">date_start_back</span><span class="o">.</span><span class="n">values</span><span class="p">,</span> <span class="n">date_end</span><span class="o">.</span><span class="n">values</span><span class="p">,</span> <span class="n">freq</span><span class="o">=</span><span class="n">highest_resolution</span><span class="p">,</span> <span class="n">closed</span><span class="o">=</span><span class="s2">&quot;left&quot;</span>
        <span class="p">)</span><span class="o">.</span><span class="n">to_numpy</span><span class="p">()</span>

        <span class="c1"># Create low frequency flux data (monthly)</span>
        <span class="n">flux_ds_low_freq</span> <span class="o">=</span> <span class="n">flux_ds</span><span class="o">.</span><span class="n">resample</span><span class="p">({</span><span class="s2">&quot;time&quot;</span><span class="p">:</span> <span class="s2">&quot;1MS&quot;</span><span class="p">})</span><span class="o">.</span><span class="n">mean</span><span class="p">()</span><span class="o">.</span><span class="n">sel</span><span class="p">(</span><span class="n">time</span><span class="o">=</span><span class="nb">slice</span><span class="p">(</span><span class="n">date_start_back</span><span class="p">,</span> <span class="n">date_end</span><span class="p">))</span>
        <span class="n">flux_ds_low_freq</span> <span class="o">=</span> <span class="n">flux_ds_low_freq</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="o">*</span><span class="p">(</span><span class="s2">&quot;lat&quot;</span><span class="p">,</span> <span class="s2">&quot;lon&quot;</span><span class="p">,</span> <span class="s2">&quot;time&quot;</span><span class="p">))</span>

        <span class="c1"># Select and align high frequency flux data</span>
        <span class="n">flux_ds_high_freq</span> <span class="o">=</span> <span class="n">flux_ds</span><span class="o">.</span><span class="n">sel</span><span class="p">(</span><span class="n">time</span><span class="o">=</span><span class="nb">slice</span><span class="p">(</span><span class="n">date_start_back</span><span class="p">,</span> <span class="n">date_end</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">flux_res_H</span> <span class="o">&lt;=</span> <span class="mi">24</span><span class="p">:</span>
            <span class="n">base</span> <span class="o">=</span> <span class="p">(</span>
                <span class="n">date_start_back</span><span class="o">.</span><span class="n">dt</span><span class="o">.</span><span class="n">hour</span><span class="o">.</span><span class="n">data</span>
                <span class="o">+</span> <span class="n">date_start_back</span><span class="o">.</span><span class="n">dt</span><span class="o">.</span><span class="n">minute</span><span class="o">.</span><span class="n">data</span> <span class="o">/</span> <span class="mf">60.0</span>
                <span class="o">+</span> <span class="n">date_start_back</span><span class="o">.</span><span class="n">dt</span><span class="o">.</span><span class="n">second</span><span class="o">.</span><span class="n">data</span> <span class="o">/</span> <span class="mf">3600.0</span>
            <span class="p">)</span>
            <span class="k">if</span> <span class="n">flux_res_H</span> <span class="o">&lt;=</span> <span class="n">highest_res_H</span><span class="p">:</span>
                <span class="c1"># Downsample flux to match to footprints frequency</span>
                <span class="n">flux_ds_high_freq</span> <span class="o">=</span> <span class="n">flux_ds_high_freq</span><span class="o">.</span><span class="n">resample</span><span class="p">({</span><span class="s2">&quot;time&quot;</span><span class="p">:</span> <span class="n">highest_resolution</span><span class="p">},</span> <span class="n">base</span><span class="o">=</span><span class="n">base</span><span class="p">)</span><span class="o">.</span><span class="n">mean</span><span class="p">()</span>
            <span class="k">elif</span> <span class="n">flux_res_H</span> <span class="o">&gt;</span> <span class="n">highest_res_H</span><span class="p">:</span>
                <span class="c1"># Upsample flux to match footprints frequency and forward fill</span>
                <span class="n">flux_ds_high_freq</span> <span class="o">=</span> <span class="n">flux_ds_high_freq</span><span class="o">.</span><span class="n">resample</span><span class="p">(</span>
                    <span class="p">{</span><span class="s2">&quot;time&quot;</span><span class="p">:</span> <span class="n">highest_resolution</span><span class="p">},</span> <span class="n">base</span><span class="o">=</span><span class="n">base</span>
                <span class="p">)</span><span class="o">.</span><span class="n">ffill</span><span class="p">()</span>
            <span class="c1"># Reindex to match to correct values</span>
            <span class="n">flux_ds_high_freq</span> <span class="o">=</span> <span class="n">flux_ds_high_freq</span><span class="o">.</span><span class="n">reindex</span><span class="p">({</span><span class="s2">&quot;time&quot;</span><span class="p">:</span> <span class="n">full_dates</span><span class="p">},</span> <span class="n">method</span><span class="o">=</span><span class="s2">&quot;ffill&quot;</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">flux_res_H</span> <span class="o">&gt;</span> <span class="mi">24</span><span class="p">:</span>
            <span class="c1"># If flux is not high frequency use the monthly averages instead.</span>
            <span class="n">flux_ds_high_freq</span> <span class="o">=</span> <span class="n">flux_ds_low_freq</span>

        <span class="c1"># TODO: Add check to make sure time values are exactly aligned based on date range</span>

        <span class="c1"># Make sure the dimensions match the expected order for indexing</span>
        <span class="n">fp_HiTRes</span> <span class="o">=</span> <span class="n">fp_HiTRes</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="o">*</span><span class="p">(</span><span class="s2">&quot;lat&quot;</span><span class="p">,</span> <span class="s2">&quot;lon&quot;</span><span class="p">,</span> <span class="s2">&quot;time&quot;</span><span class="p">,</span> <span class="s2">&quot;H_back&quot;</span><span class="p">))</span>
        <span class="n">flux_ds_high_freq</span> <span class="o">=</span> <span class="n">flux_ds_high_freq</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="o">*</span><span class="p">(</span><span class="s2">&quot;lat&quot;</span><span class="p">,</span> <span class="s2">&quot;lon&quot;</span><span class="p">,</span> <span class="s2">&quot;time&quot;</span><span class="p">))</span>

        <span class="c1"># Extract footprints array to use in numba loop</span>
        <span class="n">fp_HiTRes</span> <span class="o">=</span> <span class="n">da</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">fp_HiTRes</span><span class="p">)</span>

        <span class="c1"># Set up a numpy array to calculate the product of the footprints (H matrix) with the fluxes</span>
        <span class="k">if</span> <span class="n">output_fpXflux</span><span class="p">:</span>
            <span class="n">fpXflux</span> <span class="o">=</span> <span class="n">da</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">nlat</span><span class="p">,</span> <span class="n">nlon</span><span class="p">,</span> <span class="n">ntime</span><span class="p">))</span>

        <span class="k">if</span> <span class="n">output_TS</span><span class="p">:</span>
            <span class="n">timeseries</span> <span class="o">=</span> <span class="n">da</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">ntime</span><span class="p">)</span>

        <span class="c1"># Iterate through the time coord to get the total mf at each time step using the H back coord</span>
        <span class="c1"># at each release time we disaggregate the particles backwards over the previous 24hrs</span>
        <span class="c1"># The final value then contains the 29-day integrated residual footprints</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Calculating modelled timeseries comparison:&quot;</span><span class="p">)</span>
        <span class="n">iters</span> <span class="o">=</span> <span class="n">tqdm</span><span class="p">(</span><span class="n">time_array</span><span class="o">.</span><span class="n">values</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">tt</span><span class="p">,</span> <span class="n">time</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">iters</span><span class="p">):</span>

            <span class="c1"># Get correct index for low resolution data based on start and current date</span>
            <span class="n">current</span> <span class="o">=</span> <span class="p">{</span><span class="n">dd</span><span class="p">:</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">datetime64</span><span class="p">(</span><span class="n">time</span><span class="p">,</span> <span class="s2">&quot;h&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">object</span><span class="p">),</span> <span class="n">dd</span><span class="p">)</span> <span class="k">for</span> <span class="n">dd</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;month&quot;</span><span class="p">,</span> <span class="s2">&quot;year&quot;</span><span class="p">]}</span>
            <span class="n">tt_low</span> <span class="o">=</span> <span class="n">current</span><span class="p">[</span><span class="s2">&quot;month&quot;</span><span class="p">]</span> <span class="o">-</span> <span class="n">start</span><span class="p">[</span><span class="s2">&quot;month&quot;</span><span class="p">]</span> <span class="o">+</span> <span class="mi">12</span> <span class="o">*</span> <span class="p">(</span><span class="n">current</span><span class="p">[</span><span class="s2">&quot;year&quot;</span><span class="p">]</span> <span class="o">-</span> <span class="n">start</span><span class="p">[</span><span class="s2">&quot;year&quot;</span><span class="p">])</span>

            <span class="c1"># get 4 dimensional chunk of high time res footprints for this timestep</span>
            <span class="c1"># units : mol/mol/mol/m2/s</span>
            <span class="c1"># reverse the time coordinate to be chronological</span>
            <span class="n">fp_time</span> <span class="o">=</span> <span class="n">fp_HiTRes</span><span class="p">[:,</span> <span class="p">:,</span> <span class="n">tt</span><span class="p">,</span> <span class="p">::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

            <span class="n">fp_high_freq</span> <span class="o">=</span> <span class="n">fp_time</span><span class="p">[:,</span> <span class="p">:,</span> <span class="mi">1</span><span class="p">:]</span>
            <span class="n">fp_residual</span> <span class="o">=</span> <span class="n">fp_time</span><span class="p">[:,</span> <span class="p">:,</span> <span class="mi">0</span><span class="p">:</span><span class="mi">1</span><span class="p">]</span>  <span class="c1"># First element (reversed) contains residual footprints</span>

            <span class="c1"># Extract flux data from dataset</span>
            <span class="n">flux_high_freq</span> <span class="o">=</span> <span class="n">flux_ds_high_freq</span><span class="o">.</span><span class="n">flux</span>
            <span class="n">flux_low_freq</span> <span class="o">=</span> <span class="n">flux_ds_low_freq</span><span class="o">.</span><span class="n">flux</span>

            <span class="c1"># Define high and low frequency fluxes based on inputs</span>
            <span class="c1"># Allow for variable frequency within 24 hours</span>
            <span class="n">flux_low_freq</span> <span class="o">=</span> <span class="n">flux_low_freq</span><span class="p">[:,</span> <span class="p">:,</span> <span class="n">tt_low</span> <span class="p">:</span> <span class="n">tt_low</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">flux_res_H</span> <span class="o">&lt;=</span> <span class="mi">24</span><span class="p">:</span>
                <span class="c1"># Define indices to correctly select matching date range from flux data</span>
                <span class="c1"># This will depend on the various frequencies of the inputs</span>
                <span class="c1"># At present, highest_res_H matches the flux frequency</span>
                <span class="n">tt_start</span> <span class="o">=</span> <span class="n">tt</span> <span class="o">*</span> <span class="nb">int</span><span class="p">(</span><span class="n">time_res_H</span> <span class="o">/</span> <span class="n">highest_res_H</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span>
                <span class="n">tt_end</span> <span class="o">=</span> <span class="n">tt_start</span> <span class="o">+</span> <span class="nb">int</span><span class="p">(</span><span class="n">max_h_back</span> <span class="o">/</span> <span class="n">highest_res_H</span><span class="p">)</span>
                <span class="n">selection</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">time_hf_res_H</span> <span class="o">/</span> <span class="n">highest_res_H</span><span class="p">)</span>

                <span class="c1"># Extract matching time range from whole flux array</span>
                <span class="n">flux_high_freq</span> <span class="o">=</span> <span class="n">flux_high_freq</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="n">tt_start</span><span class="p">:</span><span class="n">tt_end</span><span class="p">]</span>
                <span class="k">if</span> <span class="n">selection</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="c1"># If flux frequency does not match to the high frequency (hf, H_back)</span>
                    <span class="c1"># dimension, select entries which do. Reversed to make sure</span>
                    <span class="c1"># entries matching to the correct times are selected</span>
                    <span class="n">flux_high_freq</span> <span class="o">=</span> <span class="n">flux_high_freq</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="p">::</span><span class="o">-</span><span class="n">selection</span><span class="p">]</span>
                    <span class="n">flux_high_freq</span> <span class="o">=</span> <span class="n">flux_high_freq</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="p">::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">flux_high_freq</span> <span class="o">=</span> <span class="n">flux_high_freq</span><span class="p">[:,</span> <span class="p">:,</span> <span class="n">tt_low</span> <span class="p">:</span> <span class="n">tt_low</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span>

            <span class="c1"># convert to array to use in numba loop</span>
            <span class="n">flux_high_freq</span> <span class="o">=</span> <span class="n">da</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">flux_high_freq</span><span class="p">)</span>
            <span class="n">flux_low_freq</span> <span class="o">=</span> <span class="n">da</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">flux_low_freq</span><span class="p">)</span>

            <span class="c1"># Multiply the HiTRes footprints with the HiTRes emissions to give mf</span>
            <span class="c1"># Multiply residual footprints by low frequency emissions data to give residual mf</span>
            <span class="c1"># flux units : mol/m2/s;       fp units : mol/mol/mol/m2/s</span>
            <span class="c1"># --&gt; mol/mol/mol/m2/s * mol/m2/s === mol / mol</span>
            <span class="n">fpXflux_time</span> <span class="o">=</span> <span class="n">flux_high_freq</span> <span class="o">*</span> <span class="n">fp_high_freq</span>
            <span class="n">fpXflux_residual</span> <span class="o">=</span> <span class="n">flux_low_freq</span> <span class="o">*</span> <span class="n">fp_residual</span>

            <span class="c1"># append the residual emissions</span>
            <span class="n">fpXflux_time</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dstack</span><span class="p">((</span><span class="n">fpXflux_time</span><span class="p">,</span> <span class="n">fpXflux_residual</span><span class="p">))</span>

            <span class="k">if</span> <span class="n">output_fpXflux</span><span class="p">:</span>
                <span class="c1"># Sum over time (H back) to give the total mf at this timestep</span>
                <span class="n">fpXflux</span><span class="p">[:,</span> <span class="p">:,</span> <span class="n">tt</span><span class="p">]</span> <span class="o">=</span> <span class="n">fpXflux_time</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">output_TS</span><span class="p">:</span>
                <span class="c1"># work out timeseries by summing over lat, lon (24 hrs)</span>
                <span class="n">timeseries</span><span class="p">[</span><span class="n">tt</span><span class="p">]</span> <span class="o">=</span> <span class="n">fpXflux_time</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>

        <span class="c1"># TODO: Add details about units to output</span>

        <span class="k">if</span> <span class="n">output_fpXflux</span><span class="p">:</span>
            <span class="n">fpXflux</span> <span class="o">=</span> <span class="n">DataArray</span><span class="p">(</span>
                <span class="n">fpXflux</span><span class="p">,</span>
                <span class="n">dims</span><span class="o">=</span><span class="p">(</span><span class="s2">&quot;lat&quot;</span><span class="p">,</span> <span class="s2">&quot;lon&quot;</span><span class="p">,</span> <span class="s2">&quot;time&quot;</span><span class="p">),</span>
                <span class="n">coords</span><span class="o">=</span><span class="p">{</span><span class="s2">&quot;lat&quot;</span><span class="p">:</span> <span class="n">lat</span><span class="p">,</span> <span class="s2">&quot;lon&quot;</span><span class="p">:</span> <span class="n">lon</span><span class="p">,</span> <span class="s2">&quot;time&quot;</span><span class="p">:</span> <span class="n">time_array</span><span class="p">},</span>
            <span class="p">)</span>

        <span class="k">if</span> <span class="n">output_TS</span><span class="p">:</span>
            <span class="n">timeseries</span> <span class="o">=</span> <span class="n">DataArray</span><span class="p">(</span><span class="n">timeseries</span><span class="p">,</span> <span class="n">dims</span><span class="o">=</span><span class="p">(</span><span class="s2">&quot;time&quot;</span><span class="p">),</span> <span class="n">coords</span><span class="o">=</span><span class="p">{</span><span class="s2">&quot;time&quot;</span><span class="p">:</span> <span class="n">time_array</span><span class="p">})</span>

        <span class="k">if</span> <span class="n">output_fpXflux</span> <span class="ow">and</span> <span class="n">output_TS</span><span class="p">:</span>
            <span class="n">timeseries</span><span class="o">.</span><span class="n">compute</span><span class="p">()</span>
            <span class="n">fpXflux</span><span class="o">.</span><span class="n">compute</span><span class="p">()</span>
            <span class="k">return</span> <span class="n">timeseries</span><span class="p">,</span> <span class="n">fpXflux</span>
        <span class="k">elif</span> <span class="n">output_fpXflux</span><span class="p">:</span>
            <span class="n">fpXflux</span><span class="o">.</span><span class="n">compute</span><span class="p">()</span>
            <span class="k">return</span> <span class="n">fpXflux</span>
        <span class="k">elif</span> <span class="n">output_TS</span><span class="p">:</span>
            <span class="n">timeseries</span><span class="o">.</span><span class="n">compute</span><span class="p">()</span>
            <span class="k">return</span> <span class="n">timeseries</span>

        <span class="k">return</span> <span class="kc">None</span>

<div class="viewcode-block" id="ModelScenario.calc_modelled_baseline"><a class="viewcode-back" href="../../../api/api_analyse.html#openghg.analyse.ModelScenario.calc_modelled_baseline">[docs]</a>    <span class="k">def</span> <span class="nf">calc_modelled_baseline</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">resample_to</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;coarsest&quot;</span><span class="p">,</span>
        <span class="n">platform</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">output_units</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">1e-9</span><span class="p">,</span>
        <span class="n">cache</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="n">recalculate</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">DataArray</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Calculate the modelled baseline points based on site footprint and boundary conditions.</span>
<span class="sd">        Boundary conditions are multipled by any loss (exp(-t/lifetime)) for the species.</span>

<span class="sd">        The time points returned are dependent on the resample_to option chosen.</span>
<span class="sd">        If obs data is also linked to the ModelScenario instance, this will be used</span>
<span class="sd">        to derive the time points where appropriate.</span>

<span class="sd">        Args:</span>
<span class="sd">            resample_to: Resample option to use for averaging:</span>
<span class="sd">                          - either one of [&quot;coarsest&quot;, &quot;obs&quot;, &quot;footprint&quot;] to match to the datasets</span>
<span class="sd">                          - or using a valid pandas resample period e.g. &quot;2H&quot;.</span>
<span class="sd">                         Default = &quot;coarsest&quot;.</span>
<span class="sd">            platform: Observation platform used to decide whether to resample e.g. &quot;site&quot;, &quot;satellite&quot;.</span>
<span class="sd">            cache: Cache this data after calculation. Default = True.</span>
<span class="sd">            recalculate: Make sure to recalculate this data rather than return from cache. Default = False.</span>

<span class="sd">        Returns:</span>
<span class="sd">            xarray.DataArray: Modelled baselined values along the time axis</span>

<span class="sd">            If cache is True:</span>
<span class="sd">                This data will also be cached as the ModelScenario.modelled_baseline attribute.</span>
<span class="sd">                The associated scenario data will be cached as the ModelScenario.scenario attribute.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">openghg.util</span> <span class="kn">import</span> <span class="n">check_lifetime_monthly</span><span class="p">,</span> <span class="n">species_lifetime</span><span class="p">,</span> <span class="n">time_offset</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_check_data_is_present</span><span class="p">(</span><span class="n">need</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;footprint&quot;</span><span class="p">,</span> <span class="s2">&quot;bc&quot;</span><span class="p">])</span>
        <span class="n">bc</span> <span class="o">=</span> <span class="n">cast</span><span class="p">(</span><span class="n">BoundaryConditionsData</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">bc</span><span class="p">)</span>

        <span class="n">param_calculate</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_param_setup</span><span class="p">(</span>
            <span class="n">param</span><span class="o">=</span><span class="s2">&quot;modelled_baseline&quot;</span><span class="p">,</span> <span class="n">resample_to</span><span class="o">=</span><span class="n">resample_to</span><span class="p">,</span> <span class="n">platform</span><span class="o">=</span><span class="n">platform</span><span class="p">,</span> <span class="n">recalculate</span><span class="o">=</span><span class="n">recalculate</span>
        <span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">param_calculate</span><span class="p">:</span>
            <span class="n">modelled_baseline</span> <span class="o">=</span> <span class="n">cast</span><span class="p">(</span><span class="n">DataArray</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">modelled_baseline</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">modelled_baseline</span>

        <span class="n">scenario</span> <span class="o">=</span> <span class="n">cast</span><span class="p">(</span><span class="n">Dataset</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">scenario</span><span class="p">)</span>
        <span class="n">bc_data</span> <span class="o">=</span> <span class="n">bc</span><span class="o">.</span><span class="n">data</span>

        <span class="n">bc_data</span> <span class="o">=</span> <span class="n">bc_data</span><span class="o">.</span><span class="n">reindex_like</span><span class="p">(</span><span class="n">scenario</span><span class="p">,</span> <span class="s2">&quot;ffill&quot;</span><span class="p">)</span>

        <span class="n">lifetime_value</span> <span class="o">=</span> <span class="n">species_lifetime</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">species</span><span class="p">)</span>
        <span class="n">check_monthly</span> <span class="o">=</span> <span class="n">check_lifetime_monthly</span><span class="p">(</span><span class="n">lifetime_value</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">check_monthly</span><span class="p">:</span>
            <span class="n">lifetime_monthly</span> <span class="o">=</span> <span class="n">cast</span><span class="p">(</span><span class="n">Optional</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]],</span> <span class="n">lifetime_value</span><span class="p">)</span>
            <span class="n">lifetime</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">lifetime_monthly</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="n">lifetime</span> <span class="o">=</span> <span class="n">cast</span><span class="p">(</span><span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">lifetime_value</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">lifetime</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">short_lifetime</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="n">lt_time_delta</span> <span class="o">=</span> <span class="n">time_offset</span><span class="p">(</span><span class="n">period</span><span class="o">=</span><span class="n">lifetime</span><span class="p">)</span>
            <span class="n">lifetime_hrs</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]</span> <span class="o">=</span> <span class="n">lt_time_delta</span><span class="o">.</span><span class="n">total_seconds</span><span class="p">()</span> <span class="o">/</span> <span class="mf">3600.0</span>
        <span class="k">elif</span> <span class="n">lifetime_monthly</span><span class="p">:</span>
            <span class="n">short_lifetime</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="n">lifetime_monthly_hrs</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">lt</span> <span class="ow">in</span> <span class="n">lifetime_monthly</span><span class="p">:</span>
                <span class="n">lt_time_delta</span> <span class="o">=</span> <span class="n">time_offset</span><span class="p">(</span><span class="n">period</span><span class="o">=</span><span class="n">lt</span><span class="p">)</span>
                <span class="n">lt_hrs</span> <span class="o">=</span> <span class="n">lt_time_delta</span><span class="o">.</span><span class="n">total_seconds</span><span class="p">()</span> <span class="o">/</span> <span class="mf">3600.0</span>
                <span class="n">lifetime_monthly_hrs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">lt_hrs</span><span class="p">)</span>

            <span class="c1"># calculate the lifetime_hrs associated with each time point in scenario data</span>
            <span class="c1"># this is because lifetime can be a list of monthly values</span>
            <span class="n">time_month</span> <span class="o">=</span> <span class="n">scenario</span><span class="p">[</span><span class="s2">&quot;time&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">dt</span><span class="o">.</span><span class="n">month</span>
            <span class="n">lifetime_hrs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">lifetime_monthly_hrs</span><span class="p">[</span><span class="n">item</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">time_month</span><span class="o">.</span><span class="n">values</span><span class="p">])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">short_lifetime</span> <span class="o">=</span> <span class="kc">False</span>

        <span class="c1"># Include loss condition if lifetime of species is specified</span>
        <span class="k">if</span> <span class="n">short_lifetime</span><span class="p">:</span>
            <span class="n">expected_vars</span> <span class="o">=</span> <span class="p">(</span>
                <span class="s2">&quot;mean_age_particles_n&quot;</span><span class="p">,</span>
                <span class="s2">&quot;mean_age_particles_e&quot;</span><span class="p">,</span>
                <span class="s2">&quot;mean_age_particles_s&quot;</span><span class="p">,</span>
                <span class="s2">&quot;mean_age_particles_w&quot;</span><span class="p">,</span>
            <span class="p">)</span>
            <span class="k">for</span> <span class="n">var</span> <span class="ow">in</span> <span class="n">expected_vars</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">var</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">scenario</span><span class="o">.</span><span class="n">data_vars</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                        <span class="sa">f</span><span class="s2">&quot;Unable to calculate baseline for short-lived species </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">species</span><span class="si">}</span><span class="s2"> without species specific footprint.&quot;</span>
                    <span class="p">)</span>

            <span class="c1"># Ignoring type below -  - problem with xarray patching np.exp to return DataArray rather than ndarray</span>
            <span class="n">loss_n</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">DataArray</span><span class="p">,</span> <span class="nb">float</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span> <span class="o">*</span> <span class="n">scenario</span><span class="p">[</span><span class="s2">&quot;mean_age_particles_n&quot;</span><span class="p">]</span> <span class="o">/</span> <span class="n">lifetime_hrs</span><span class="p">)</span><span class="o">.</span><span class="n">rename</span><span class="p">(</span><span class="s2">&quot;loss_n&quot;</span><span class="p">)</span>  <span class="c1"># type: ignore</span>
            <span class="n">loss_e</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">DataArray</span><span class="p">,</span> <span class="nb">float</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span> <span class="o">*</span> <span class="n">scenario</span><span class="p">[</span><span class="s2">&quot;mean_age_particles_e&quot;</span><span class="p">]</span> <span class="o">/</span> <span class="n">lifetime_hrs</span><span class="p">)</span><span class="o">.</span><span class="n">rename</span><span class="p">(</span><span class="s2">&quot;loss_e&quot;</span><span class="p">)</span>  <span class="c1"># type: ignore</span>
            <span class="n">loss_s</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">DataArray</span><span class="p">,</span> <span class="nb">float</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span> <span class="o">*</span> <span class="n">scenario</span><span class="p">[</span><span class="s2">&quot;mean_age_particles_s&quot;</span><span class="p">]</span> <span class="o">/</span> <span class="n">lifetime_hrs</span><span class="p">)</span><span class="o">.</span><span class="n">rename</span><span class="p">(</span><span class="s2">&quot;loss_s&quot;</span><span class="p">)</span>  <span class="c1"># type: ignore</span>
            <span class="n">loss_w</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">DataArray</span><span class="p">,</span> <span class="nb">float</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span> <span class="o">*</span> <span class="n">scenario</span><span class="p">[</span><span class="s2">&quot;mean_age_particles_w&quot;</span><span class="p">]</span> <span class="o">/</span> <span class="n">lifetime_hrs</span><span class="p">)</span><span class="o">.</span><span class="n">rename</span><span class="p">(</span><span class="s2">&quot;loss_w&quot;</span><span class="p">)</span>  <span class="c1"># type: ignore</span>

        <span class="k">else</span><span class="p">:</span>

            <span class="n">loss_n</span> <span class="o">=</span> <span class="mf">1.0</span>
            <span class="n">loss_e</span> <span class="o">=</span> <span class="mf">1.0</span>
            <span class="n">loss_s</span> <span class="o">=</span> <span class="mf">1.0</span>
            <span class="n">loss_w</span> <span class="o">=</span> <span class="mf">1.0</span>

        <span class="c1"># Check and extract units as float, if present.</span>
        <span class="n">units_default</span> <span class="o">=</span> <span class="mf">1.0</span>
        <span class="n">units_n</span> <span class="o">=</span> <span class="n">check_units</span><span class="p">(</span><span class="n">bc_data</span><span class="p">[</span><span class="s2">&quot;vmr_n&quot;</span><span class="p">],</span> <span class="n">default</span><span class="o">=</span><span class="n">units_default</span><span class="p">)</span>
        <span class="n">units_e</span> <span class="o">=</span> <span class="n">check_units</span><span class="p">(</span><span class="n">bc_data</span><span class="p">[</span><span class="s2">&quot;vmr_e&quot;</span><span class="p">],</span> <span class="n">default</span><span class="o">=</span><span class="n">units_default</span><span class="p">)</span>
        <span class="n">units_s</span> <span class="o">=</span> <span class="n">check_units</span><span class="p">(</span><span class="n">bc_data</span><span class="p">[</span><span class="s2">&quot;vmr_s&quot;</span><span class="p">],</span> <span class="n">default</span><span class="o">=</span><span class="n">units_default</span><span class="p">)</span>
        <span class="n">units_w</span> <span class="o">=</span> <span class="n">check_units</span><span class="p">(</span><span class="n">bc_data</span><span class="p">[</span><span class="s2">&quot;vmr_w&quot;</span><span class="p">],</span> <span class="n">default</span><span class="o">=</span><span class="n">units_default</span><span class="p">)</span>

        <span class="n">modelled_baseline</span> <span class="o">=</span> <span class="p">(</span>
            <span class="p">(</span><span class="n">scenario</span><span class="p">[</span><span class="s2">&quot;particle_locations_n&quot;</span><span class="p">]</span> <span class="o">*</span> <span class="n">bc_data</span><span class="p">[</span><span class="s2">&quot;vmr_n&quot;</span><span class="p">]</span> <span class="o">*</span> <span class="n">loss_n</span> <span class="o">*</span> <span class="n">units_n</span> <span class="o">/</span> <span class="n">output_units</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">([</span><span class="s2">&quot;height&quot;</span><span class="p">,</span> <span class="s2">&quot;lon&quot;</span><span class="p">])</span>
            <span class="o">+</span> <span class="p">(</span><span class="n">scenario</span><span class="p">[</span><span class="s2">&quot;particle_locations_e&quot;</span><span class="p">]</span> <span class="o">*</span> <span class="n">bc_data</span><span class="p">[</span><span class="s2">&quot;vmr_e&quot;</span><span class="p">]</span> <span class="o">*</span> <span class="n">loss_e</span> <span class="o">*</span> <span class="n">units_e</span> <span class="o">/</span> <span class="n">output_units</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">([</span><span class="s2">&quot;height&quot;</span><span class="p">,</span> <span class="s2">&quot;lat&quot;</span><span class="p">])</span>
            <span class="o">+</span> <span class="p">(</span><span class="n">scenario</span><span class="p">[</span><span class="s2">&quot;particle_locations_s&quot;</span><span class="p">]</span> <span class="o">*</span> <span class="n">bc_data</span><span class="p">[</span><span class="s2">&quot;vmr_s&quot;</span><span class="p">]</span> <span class="o">*</span> <span class="n">loss_s</span> <span class="o">*</span> <span class="n">units_s</span> <span class="o">/</span> <span class="n">output_units</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">([</span><span class="s2">&quot;height&quot;</span><span class="p">,</span> <span class="s2">&quot;lon&quot;</span><span class="p">])</span>
            <span class="o">+</span> <span class="p">(</span><span class="n">scenario</span><span class="p">[</span><span class="s2">&quot;particle_locations_w&quot;</span><span class="p">]</span> <span class="o">*</span> <span class="n">bc_data</span><span class="p">[</span><span class="s2">&quot;vmr_w&quot;</span><span class="p">]</span> <span class="o">*</span> <span class="n">loss_w</span> <span class="o">*</span> <span class="n">units_w</span> <span class="o">/</span> <span class="n">output_units</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">([</span><span class="s2">&quot;height&quot;</span><span class="p">,</span> <span class="s2">&quot;lat&quot;</span><span class="p">])</span>
        <span class="p">)</span>

        <span class="n">modelled_baseline</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="s2">&quot;resample_to&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">resample_to</span>
        <span class="n">modelled_baseline</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="s2">&quot;units&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">output_units</span>
        <span class="n">modelled_baseline</span> <span class="o">=</span> <span class="n">modelled_baseline</span><span class="o">.</span><span class="n">rename</span><span class="p">(</span><span class="s2">&quot;bc_mod&quot;</span><span class="p">)</span>

        <span class="c1"># Cache output from calculations</span>
        <span class="k">if</span> <span class="n">cache</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Caching calculated data&quot;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">modelled_baseline</span> <span class="o">=</span> <span class="n">modelled_baseline</span>
            <span class="c1"># self.scenario[name] = modelled_obs</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">modelled_baseline</span> <span class="o">=</span> <span class="kc">None</span>  <span class="c1"># Make sure this is reset and not cached</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">scenario</span> <span class="o">=</span> <span class="kc">None</span>  <span class="c1"># Reset this to None after calculation completed</span>

        <span class="k">return</span> <span class="n">modelled_baseline</span></div>

    <span class="c1"># def _calc_modelled_baseline_long_lived():</span>
    <span class="c1">#     pass</span>

    <span class="c1"># def _calc_modelled_baseline_short_lived():</span>
    <span class="c1">#     pass</span>

<div class="viewcode-block" id="ModelScenario.footprints_data_merge"><a class="viewcode-back" href="../../../api/api_analyse.html#openghg.analyse.ModelScenario.footprints_data_merge">[docs]</a>    <span class="k">def</span> <span class="nf">footprints_data_merge</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">resample_to</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;coarsest&quot;</span><span class="p">,</span>
        <span class="n">platform</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">calc_timeseries</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="n">sources</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">List</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">calc_bc</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="n">cache</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="n">recalculate</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Dataset</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Produce combined object containing aligned footprint and observation data.</span>
<span class="sd">        Can also include modelled timeseries data derived from flux.</span>

<span class="sd">        Args:</span>
<span class="sd">            resample_to: Resample option to use for averaging:</span>
<span class="sd">                          - either one of [&quot;coarsest&quot;, &quot;obs&quot;, &quot;footprint&quot;] to match to the datasets</span>
<span class="sd">                          - or using a valid pandas resample period e.g. &quot;2H&quot;.</span>
<span class="sd">                         Default = &quot;coarsest&quot;.</span>
<span class="sd">            platform: Observation platform used to decide whether to resample.</span>
<span class="sd">            calc_timeseries: Calculate modelled timeseries based on flux sources.</span>
<span class="sd">            sources: Sources to use for flux if calc_timseries is True.</span>
<span class="sd">                     All will be used and stacked if not specified.</span>
<span class="sd">            calc_baseline: Calculate modelled baseline.</span>
<span class="sd">            cache: Cache this data after calculation. Default = True.</span>
<span class="sd">            recalculate: Make sure to recalculate this data rather than return from cache. Default = False.</span>

<span class="sd">        Returns:</span>
<span class="sd">            xarray.Dataset: Combined dataset containing footprint and observation data</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">combined_dataset</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">combine_obs_footprint</span><span class="p">(</span>
            <span class="n">resample_to</span><span class="o">=</span><span class="n">resample_to</span><span class="p">,</span> <span class="n">platform</span><span class="o">=</span><span class="n">platform</span><span class="p">,</span> <span class="n">cache</span><span class="o">=</span><span class="n">cache</span><span class="p">,</span> <span class="n">recalculate</span><span class="o">=</span><span class="n">recalculate</span>
        <span class="p">)</span>

        <span class="k">if</span> <span class="n">calc_timeseries</span><span class="p">:</span>
            <span class="n">modelled_obs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">calc_modelled_obs</span><span class="p">(</span>
                <span class="n">resample_to</span><span class="o">=</span><span class="n">resample_to</span><span class="p">,</span>
                <span class="n">sources</span><span class="o">=</span><span class="n">sources</span><span class="p">,</span>
                <span class="n">platform</span><span class="o">=</span><span class="n">platform</span><span class="p">,</span>
                <span class="n">cache</span><span class="o">=</span><span class="n">cache</span><span class="p">,</span>
                <span class="n">recalculate</span><span class="o">=</span><span class="n">recalculate</span><span class="p">,</span>
            <span class="p">)</span>

            <span class="n">name</span> <span class="o">=</span> <span class="n">modelled_obs</span><span class="o">.</span><span class="n">name</span>
            <span class="n">combined_dataset</span> <span class="o">=</span> <span class="n">combined_dataset</span><span class="o">.</span><span class="n">assign</span><span class="p">({</span><span class="n">name</span><span class="p">:</span> <span class="n">modelled_obs</span><span class="p">})</span>

        <span class="k">if</span> <span class="n">calc_bc</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">bc</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">modelled_baseline</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">calc_modelled_baseline</span><span class="p">(</span>
                    <span class="n">resample_to</span><span class="o">=</span><span class="n">resample_to</span><span class="p">,</span>
                    <span class="n">platform</span><span class="o">=</span><span class="n">platform</span><span class="p">,</span>
                    <span class="n">cache</span><span class="o">=</span><span class="n">cache</span><span class="p">,</span>
                    <span class="n">recalculate</span><span class="o">=</span><span class="n">recalculate</span><span class="p">,</span>
                <span class="p">)</span>
                <span class="n">name</span> <span class="o">=</span> <span class="n">modelled_baseline</span><span class="o">.</span><span class="n">name</span>
                <span class="n">combined_dataset</span> <span class="o">=</span> <span class="n">combined_dataset</span><span class="o">.</span><span class="n">assign</span><span class="p">({</span><span class="n">name</span><span class="p">:</span> <span class="n">modelled_baseline</span><span class="p">})</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span>
                    <span class="s2">&quot;Unable to calculate baseline data. Add boundary conditions using ModelScenarion.add_bc(...) to do this.&quot;</span>
                <span class="p">)</span>

        <span class="k">if</span> <span class="n">cache</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">scenario</span> <span class="o">=</span> <span class="n">combined_dataset</span>

        <span class="k">return</span> <span class="n">combined_dataset</span></div>

<div class="viewcode-block" id="ModelScenario.plot_timeseries"><a class="viewcode-back" href="../../../api/api_analyse.html#openghg.analyse.ModelScenario.plot_timeseries">[docs]</a>    <span class="k">def</span> <span class="nf">plot_timeseries</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Any</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Plot the observation timeseries data.</span>

<span class="sd">        Returns:</span>
<span class="sd">            Plotly Figure</span>

<span class="sd">            Interactive plotly graph created with observations</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_check_data_is_present</span><span class="p">(</span><span class="n">need</span><span class="o">=</span><span class="s2">&quot;obs&quot;</span><span class="p">)</span>
        <span class="n">obs</span> <span class="o">=</span> <span class="n">cast</span><span class="p">(</span><span class="n">ObsData</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">obs</span><span class="p">)</span>

        <span class="n">fig</span> <span class="o">=</span> <span class="n">obs</span><span class="o">.</span><span class="n">plot_timeseries</span><span class="p">()</span>  <span class="c1"># Calling method on ObsData class</span>

        <span class="k">return</span> <span class="n">fig</span></div>

<div class="viewcode-block" id="ModelScenario.plot_comparison"><a class="viewcode-back" href="../../../api/api_analyse.html#openghg.analyse.ModelScenario.plot_comparison">[docs]</a>    <span class="k">def</span> <span class="nf">plot_comparison</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">baseline</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;boundary_conditions&quot;</span><span class="p">,</span>
        <span class="n">sources</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">List</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">resample_to</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;coarsest&quot;</span><span class="p">,</span>
        <span class="n">platform</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">cache</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="n">recalculate</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Any</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Plot comparison between observation and modelled timeseries data.</span>

<span class="sd">        Args:</span>
<span class="sd">            baseline: Add baseline to data. One of:</span>
<span class="sd">                          - &quot;boundary_conditions&quot; - Uses added boundary conditions to calculate modelled baseline</span>
<span class="sd">                          - &quot;percentile&quot; - Calculates the 1% value across the whole time period</span>
<span class="sd">                          - None - don&#39;t add a baseline and only plot the modelled observations</span>
<span class="sd">            sources: Sources to use for flux. All will be used and stacked if not specified.</span>
<span class="sd">            resample_to: Resample option to use for averaging:</span>
<span class="sd">                          - either one of [&quot;coarsest&quot;, &quot;obs&quot;, &quot;footprint&quot;] to match to the datasets</span>
<span class="sd">                          - or using a valid pandas resample period e.g. &quot;2H&quot;.</span>
<span class="sd">                         Default = &quot;coarsest&quot;.</span>
<span class="sd">            platform: Observation platform used to decide whether to resample e.g. &quot;site&quot;, &quot;satellite&quot;.</span>
<span class="sd">            cache: Cache this data after calculation. Default = True.</span>
<span class="sd">            recalculate: Make sure to recalculate this data rather than return from cache. Default = False.</span>

<span class="sd">        Returns:</span>
<span class="sd">            Plotly Figure</span>

<span class="sd">            Interactive plotly graph created with observation and modelled observation data.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Only import plotly when we need to - not needed if not plotting.</span>
        <span class="kn">import</span> <span class="nn">plotly.graph_objects</span> <span class="k">as</span> <span class="nn">go</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_check_data_is_present</span><span class="p">(</span><span class="n">need</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;obs&quot;</span><span class="p">,</span> <span class="s2">&quot;footprint&quot;</span><span class="p">,</span> <span class="s2">&quot;flux&quot;</span><span class="p">])</span>
        <span class="n">obs</span> <span class="o">=</span> <span class="n">cast</span><span class="p">(</span><span class="n">ObsData</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">obs</span><span class="p">)</span>

        <span class="n">fig</span> <span class="o">=</span> <span class="n">obs</span><span class="o">.</span><span class="n">plot_timeseries</span><span class="p">()</span>

        <span class="n">modelled_obs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">calc_modelled_obs</span><span class="p">(</span>
            <span class="n">sources</span><span class="o">=</span><span class="n">sources</span><span class="p">,</span> <span class="n">resample_to</span><span class="o">=</span><span class="n">resample_to</span><span class="p">,</span> <span class="n">platform</span><span class="o">=</span><span class="n">platform</span><span class="p">,</span> <span class="n">cache</span><span class="o">=</span><span class="n">cache</span><span class="p">,</span> <span class="n">recalculate</span><span class="o">=</span><span class="n">recalculate</span>
        <span class="p">)</span>
        <span class="n">x_data</span> <span class="o">=</span> <span class="n">modelled_obs</span><span class="p">[</span><span class="s2">&quot;time&quot;</span><span class="p">]</span>
        <span class="n">y_data</span> <span class="o">=</span> <span class="n">modelled_obs</span><span class="o">.</span><span class="n">data</span>

        <span class="n">species</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">species</span>
        <span class="k">if</span> <span class="n">sources</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">sources</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">flux_sources</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">sources</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="n">sources</span> <span class="o">=</span> <span class="p">[</span><span class="n">sources</span><span class="p">]</span>

        <span class="k">if</span> <span class="n">sources</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">source_str</span> <span class="o">=</span> <span class="s2">&quot;, &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">sources</span><span class="p">)</span>
            <span class="n">label</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;Modelled </span><span class="si">{</span><span class="n">species</span><span class="o">.</span><span class="n">upper</span><span class="p">()</span><span class="si">}</span><span class="s2">: </span><span class="si">{</span><span class="n">source_str</span><span class="si">}</span><span class="s2">&quot;</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">label</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;Modelled </span><span class="si">{</span><span class="n">species</span><span class="o">.</span><span class="n">upper</span><span class="p">()</span><span class="si">}</span><span class="s2">&quot;</span>

        <span class="c1"># TODO: Check modelled_obs units and ensure these match to modelled_baseline</span>
        <span class="c1"># - currently modelled_baseline outputs in 1e-9 (ppb) by default.</span>

        <span class="k">if</span> <span class="n">baseline</span> <span class="o">==</span> <span class="s2">&quot;boundary_conditions&quot;</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">bc</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">modelled_baseline</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">calc_modelled_baseline</span><span class="p">(</span>
                    <span class="n">resample_to</span><span class="o">=</span><span class="n">resample_to</span><span class="p">,</span> <span class="n">platform</span><span class="o">=</span><span class="n">platform</span><span class="p">,</span> <span class="n">cache</span><span class="o">=</span><span class="n">cache</span><span class="p">,</span> <span class="n">recalculate</span><span class="o">=</span><span class="n">recalculate</span>
                <span class="p">)</span>
                <span class="n">y_baseline</span> <span class="o">=</span> <span class="n">modelled_baseline</span><span class="o">.</span><span class="n">data</span>
                <span class="n">y_data</span> <span class="o">=</span> <span class="n">y_data</span> <span class="o">+</span> <span class="n">y_baseline</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Unable to calculate baseline from boundary conditions&quot;</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">baseline</span> <span class="o">==</span> <span class="s2">&quot;percentile&quot;</span><span class="p">:</span>
            <span class="n">mf</span> <span class="o">=</span> <span class="n">obs</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;mf&quot;</span><span class="p">]</span>
            <span class="n">y_baseline</span> <span class="o">=</span> <span class="n">mf</span><span class="o">.</span><span class="n">quantile</span><span class="p">(</span><span class="mf">1.0</span><span class="p">,</span> <span class="n">dim</span><span class="o">=</span><span class="s2">&quot;time&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">values</span>
            <span class="n">y_data</span> <span class="o">=</span> <span class="n">y_data</span> <span class="o">+</span> <span class="n">y_baseline</span>

        <span class="n">fig</span><span class="o">.</span><span class="n">add_trace</span><span class="p">(</span><span class="n">go</span><span class="o">.</span><span class="n">Scatter</span><span class="p">(</span><span class="n">x</span><span class="o">=</span><span class="n">x_data</span><span class="p">,</span> <span class="n">y</span><span class="o">=</span><span class="n">y_data</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s2">&quot;lines&quot;</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="n">label</span><span class="p">))</span>

        <span class="k">return</span> <span class="n">fig</span></div></div>


<span class="k">def</span> <span class="nf">_indexes_match</span><span class="p">(</span><span class="n">dataset_A</span><span class="p">:</span> <span class="n">Dataset</span><span class="p">,</span> <span class="n">dataset_B</span><span class="p">:</span> <span class="n">Dataset</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Check if two datasets need to be reindexed_like for combine_datasets</span>

<span class="sd">    Args:</span>
<span class="sd">        dataset_A: First dataset to check</span>
<span class="sd">        dataset_B: Second dataset to check</span>
<span class="sd">    Returns:</span>
<span class="sd">        bool: True if indexes match, else False</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">common_indices</span> <span class="o">=</span> <span class="p">(</span><span class="n">key</span> <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">dataset_A</span><span class="o">.</span><span class="n">indexes</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span> <span class="k">if</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">dataset_B</span><span class="o">.</span><span class="n">indexes</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>

    <span class="k">for</span> <span class="n">index</span> <span class="ow">in</span> <span class="n">common_indices</span><span class="p">:</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">len</span><span class="p">(</span><span class="n">dataset_A</span><span class="o">.</span><span class="n">indexes</span><span class="p">[</span><span class="n">index</span><span class="p">])</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">dataset_B</span><span class="o">.</span><span class="n">indexes</span><span class="p">[</span><span class="n">index</span><span class="p">]):</span>
            <span class="k">return</span> <span class="kc">False</span>

        <span class="c1"># Check number of values that are not close (testing for equality with floating point)</span>
        <span class="k">if</span> <span class="n">index</span> <span class="o">==</span> <span class="s2">&quot;time&quot;</span><span class="p">:</span>
            <span class="c1"># For time override the default to have ~ second precision</span>
            <span class="n">rtol</span> <span class="o">=</span> <span class="mf">1e-10</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">rtol</span> <span class="o">=</span> <span class="mf">1e-5</span>

        <span class="n">index_diff</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span>
            <span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">isclose</span><span class="p">(</span>
                <span class="n">dataset_A</span><span class="o">.</span><span class="n">indexes</span><span class="p">[</span><span class="n">index</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">float</span><span class="p">),</span>
                <span class="n">dataset_B</span><span class="o">.</span><span class="n">indexes</span><span class="p">[</span><span class="n">index</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">float</span><span class="p">),</span>
                <span class="n">rtol</span><span class="o">=</span><span class="n">rtol</span><span class="p">,</span>
            <span class="p">)</span>
        <span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">index_diff</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">False</span>

    <span class="k">return</span> <span class="kc">True</span>


<span class="k">def</span> <span class="nf">combine_datasets</span><span class="p">(</span>
    <span class="n">dataset_A</span><span class="p">:</span> <span class="n">Dataset</span><span class="p">,</span> <span class="n">dataset_B</span><span class="p">:</span> <span class="n">Dataset</span><span class="p">,</span> <span class="n">method</span><span class="p">:</span> <span class="n">methodType</span> <span class="o">=</span> <span class="s2">&quot;ffill&quot;</span><span class="p">,</span> <span class="n">tolerance</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">float</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Dataset</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Merges two datasets and re-indexes to the first dataset.</span>

<span class="sd">    If &quot;fp&quot; variable is found within the combined dataset,</span>
<span class="sd">    the &quot;time&quot; values where the &quot;lat&quot;, &quot;lon&quot; dimensions didn&#39;t match are removed.</span>

<span class="sd">    Args:</span>
<span class="sd">        dataset_A: First dataset to merge</span>
<span class="sd">        dataset_B: Second dataset to merge</span>
<span class="sd">        method: One of None, nearest, ffill, bfill.</span>
<span class="sd">                See xarray.DataArray.reindex_like for list of options and meaning.</span>
<span class="sd">                Defaults to ffill (forward fill)</span>
<span class="sd">        tolerance: Maximum allowed tolerance between matches.</span>
<span class="sd">    Returns:</span>
<span class="sd">        xarray.Dataset: Combined dataset indexed to dataset_A</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">_indexes_match</span><span class="p">(</span><span class="n">dataset_A</span><span class="p">,</span> <span class="n">dataset_B</span><span class="p">):</span>
        <span class="n">dataset_B_temp</span> <span class="o">=</span> <span class="n">dataset_B</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">dataset_B_temp</span> <span class="o">=</span> <span class="n">dataset_B</span><span class="o">.</span><span class="n">reindex_like</span><span class="p">(</span><span class="n">dataset_A</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="n">method</span><span class="p">,</span> <span class="n">tolerance</span><span class="o">=</span><span class="n">tolerance</span><span class="p">)</span>

    <span class="n">merged_ds</span> <span class="o">=</span> <span class="n">dataset_A</span><span class="o">.</span><span class="n">merge</span><span class="p">(</span><span class="n">dataset_B_temp</span><span class="p">)</span>

    <span class="k">if</span> <span class="s2">&quot;fp&quot;</span> <span class="ow">in</span> <span class="n">merged_ds</span><span class="p">:</span>
        <span class="k">if</span> <span class="nb">all</span><span class="p">(</span><span class="n">k</span> <span class="ow">in</span> <span class="n">merged_ds</span><span class="o">.</span><span class="n">fp</span><span class="o">.</span><span class="n">dims</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="p">(</span><span class="s2">&quot;lat&quot;</span><span class="p">,</span> <span class="s2">&quot;long&quot;</span><span class="p">)):</span>
            <span class="n">flag</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">merged_ds</span><span class="o">.</span><span class="n">fp</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">dim</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;lat&quot;</span><span class="p">,</span> <span class="s2">&quot;lon&quot;</span><span class="p">])</span><span class="o">.</span><span class="n">values</span><span class="p">))</span>
            <span class="n">merged_ds</span> <span class="o">=</span> <span class="n">merged_ds</span><span class="p">[</span><span class="nb">dict</span><span class="p">(</span><span class="n">time</span><span class="o">=</span><span class="n">flag</span><span class="p">[</span><span class="mi">0</span><span class="p">])]</span>

    <span class="k">return</span> <span class="n">merged_ds</span>


<span class="k">def</span> <span class="nf">match_dataset_dims</span><span class="p">(</span>
    <span class="n">datasets</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">[</span><span class="n">Dataset</span><span class="p">],</span>
    <span class="n">dims</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Sequence</span><span class="p">]</span> <span class="o">=</span> <span class="p">[],</span>
    <span class="n">method</span><span class="p">:</span> <span class="n">methodType</span> <span class="o">=</span> <span class="s2">&quot;nearest&quot;</span><span class="p">,</span>
    <span class="n">tolerance</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">float</span><span class="p">]]</span> <span class="o">=</span> <span class="mf">1e-5</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">Dataset</span><span class="p">]:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Aligns datasets to the selected dimensions within a tolerance.</span>
<span class="sd">    All datasets will be aligned to the first dataset within the list.</span>

<span class="sd">    Args:</span>
<span class="sd">        datasets: List of xarray Datasets. Expect datasets to contain the same dimensions.</span>
<span class="sd">        dims: Dimensions match between datasets. Can use keyword &quot;all&quot; to match every dimension.</span>
<span class="sd">        method : Method to use for indexing. Should be one of: (&quot;nearest&quot;, &quot;ffill&quot;, &quot;bfill&quot;)</span>
<span class="sd">        tolerance: Tolerance value to use when matching coordinate values.</span>
<span class="sd">                   This can be a single value for all dimensions or a dictionary of values to use.</span>

<span class="sd">    Returns:</span>
<span class="sd">        List (xarray.Dataset) : Datasets aligned along the matching dimensions.</span>

<span class="sd">    TODO: Check if this supercedes or replicates _indexes_match() function too closely?</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># Nothing to be done if only one (or less) datasets are passed</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">datasets</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">return</span> <span class="nb">list</span><span class="p">(</span><span class="n">datasets</span><span class="p">)</span>

    <span class="n">ds0</span> <span class="o">=</span> <span class="n">datasets</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">dims</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">dims</span> <span class="o">==</span> <span class="s2">&quot;all&quot;</span><span class="p">:</span>
            <span class="n">dims</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">ds0</span><span class="o">.</span><span class="n">dims</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">dims</span> <span class="o">=</span> <span class="p">[</span><span class="n">dims</span><span class="p">]</span>

    <span class="c1"># Extract coordinate values for the first dataset in the list</span>
    <span class="n">ds0</span> <span class="o">=</span> <span class="n">datasets</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">indexers</span> <span class="o">=</span> <span class="p">{</span><span class="n">dim</span><span class="p">:</span> <span class="n">ds0</span><span class="p">[</span><span class="n">dim</span><span class="p">]</span> <span class="k">for</span> <span class="n">dim</span> <span class="ow">in</span> <span class="n">dims</span><span class="p">}</span>

    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">tolerance</span><span class="p">,</span> <span class="nb">float</span><span class="p">):</span>
        <span class="n">tolerance</span> <span class="o">=</span> <span class="p">{</span><span class="n">dim</span><span class="p">:</span> <span class="n">tolerance</span> <span class="k">for</span> <span class="n">dim</span> <span class="ow">in</span> <span class="n">dims</span><span class="p">}</span>

    <span class="c1"># Align datasets along selected dimensions (if not already identical)</span>
    <span class="n">datasets_aligned</span> <span class="o">=</span> <span class="p">[</span><span class="n">ds0</span><span class="p">]</span>
    <span class="k">for</span> <span class="n">ds</span> <span class="ow">in</span> <span class="n">datasets</span><span class="p">[</span><span class="mi">1</span><span class="p">:]:</span>
        <span class="k">for</span> <span class="n">dim</span><span class="p">,</span> <span class="n">compare_coord</span> <span class="ow">in</span> <span class="n">indexers</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">coord</span> <span class="o">=</span> <span class="n">ds</span><span class="p">[</span><span class="n">dim</span><span class="p">]</span>
            <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Dataset missing dimension: </span><span class="si">{</span><span class="n">dim</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">coord</span><span class="o">.</span><span class="n">equals</span><span class="p">(</span><span class="n">compare_coord</span><span class="p">):</span>
                    <span class="n">ds</span> <span class="o">=</span> <span class="n">ds</span><span class="o">.</span><span class="n">reindex</span><span class="p">({</span><span class="n">dim</span><span class="p">:</span> <span class="n">compare_coord</span><span class="p">},</span> <span class="n">method</span><span class="o">=</span><span class="n">method</span><span class="p">,</span> <span class="n">tolerance</span><span class="o">=</span><span class="n">tolerance</span><span class="p">[</span><span class="n">dim</span><span class="p">])</span>

        <span class="n">datasets_aligned</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">ds</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">datasets_aligned</span>


<span class="c1"># ResType = Union[np.timedelta64, float, np.floating, np.integer]</span>


<span class="k">def</span> <span class="nf">calc_dim_resolution</span><span class="p">(</span><span class="n">dataset</span><span class="p">:</span> <span class="n">Dataset</span><span class="p">,</span> <span class="n">dim</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;time&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Any</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Calculates the average frequency along a given dimension.</span>

<span class="sd">    Args:</span>
<span class="sd">        dataset : Dataset. Must contain the specified dimension</span>
<span class="sd">        dim : Dimension name</span>

<span class="sd">    Returns:</span>
<span class="sd">        np.timedelta64 / np.float / np.int : Resolution with input dtype</span>

<span class="sd">        NaT : If unsuccessful and input dtype is np.timedelta64</span>
<span class="sd">        NaN : If unsuccessful for all other dtypes.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">resolution</span> <span class="o">=</span> <span class="n">dataset</span><span class="p">[</span><span class="n">dim</span><span class="p">]</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">dim</span><span class="o">=</span><span class="n">dim</span><span class="p">)</span><span class="o">.</span><span class="n">mean</span><span class="p">()</span><span class="o">.</span><span class="n">item</span><span class="p">()</span>
    <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">issubdtype</span><span class="p">(</span><span class="n">dataset</span><span class="p">[</span><span class="n">dim</span><span class="p">]</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">datetime64</span><span class="p">):</span>
            <span class="n">resolution</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">timedelta64</span><span class="p">(</span><span class="s2">&quot;NaT&quot;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">resolution</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">NaN</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">issubdtype</span><span class="p">(</span><span class="n">dataset</span><span class="p">[</span><span class="n">dim</span><span class="p">]</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">datetime64</span><span class="p">):</span>
            <span class="c1"># Extract units from original datetime string and use to recreate timedelta64</span>
            <span class="n">unit</span> <span class="o">=</span> <span class="n">dataset</span><span class="p">[</span><span class="n">dim</span><span class="p">]</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">name</span><span class="o">.</span><span class="n">lstrip</span><span class="p">(</span><span class="s2">&quot;timedelta64&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">lstrip</span><span class="p">(</span><span class="s2">&quot;[&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">rstrip</span><span class="p">(</span><span class="s2">&quot;]&quot;</span><span class="p">)</span>
            <span class="n">resolution</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">timedelta64</span><span class="p">(</span><span class="n">resolution</span><span class="p">,</span> <span class="n">unit</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">resolution</span>


<span class="k">def</span> <span class="nf">stack_datasets</span><span class="p">(</span><span class="n">datasets</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">[</span><span class="n">Dataset</span><span class="p">],</span> <span class="n">dim</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;time&quot;</span><span class="p">,</span> <span class="n">method</span><span class="p">:</span> <span class="n">methodType</span> <span class="o">=</span> <span class="s2">&quot;ffill&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Dataset</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Stacks multiple datasets based on the input dimension. By default this is time</span>
<span class="sd">    and this will be aligned to the highest resolution / frequency</span>
<span class="sd">    (smallest difference betweeen coordinate values).</span>

<span class="sd">    At the moment, the two datasets must have identical coordinate values for all</span>
<span class="sd">    other dimensions and variable names for these to be stacked.</span>

<span class="sd">    Args:</span>
<span class="sd">        datasets : Sequence of input datasets</span>
<span class="sd">        dim : Name of dimension to stack along. Default = &quot;time&quot;</span>
<span class="sd">        method: Method to use when aligning the datasets. Default = &quot;ffill&quot;</span>

<span class="sd">    Returns:</span>
<span class="sd">        Dataset : Stacked dataset</span>

<span class="sd">    TODO: Could update this to only allow DataArrays to be included to reduce the phase</span>
<span class="sd">    space here.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">datasets</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">dataset</span> <span class="o">=</span> <span class="n">datasets</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">dataset</span>

    <span class="n">data_frequency</span> <span class="o">=</span> <span class="p">[</span><span class="n">calc_dim_resolution</span><span class="p">(</span><span class="n">ds</span><span class="p">,</span> <span class="n">dim</span><span class="p">)</span> <span class="k">for</span> <span class="n">ds</span> <span class="ow">in</span> <span class="n">datasets</span><span class="p">]</span>
    <span class="n">index_highest_freq</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">data_frequency</span><span class="p">)),</span> <span class="n">key</span><span class="o">=</span><span class="n">data_frequency</span><span class="o">.</span><span class="fm">__getitem__</span><span class="p">)</span>
    <span class="n">data_highest_freq</span> <span class="o">=</span> <span class="n">datasets</span><span class="p">[</span><span class="n">index_highest_freq</span><span class="p">]</span>
    <span class="n">coords_to_match</span> <span class="o">=</span> <span class="n">data_highest_freq</span><span class="p">[</span><span class="n">dim</span><span class="p">]</span>

    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">data</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">datasets</span><span class="p">):</span>
        <span class="n">data_match</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">reindex</span><span class="p">({</span><span class="n">dim</span><span class="p">:</span> <span class="n">coords_to_match</span><span class="p">},</span> <span class="n">method</span><span class="o">=</span><span class="n">method</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">i</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">data_stacked</span> <span class="o">=</span> <span class="n">data_match</span>
            <span class="n">data_stacked</span><span class="o">.</span><span class="n">attrs</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">data_stacked</span> <span class="o">+=</span> <span class="n">data_match</span>

    <span class="k">return</span> <span class="n">data_stacked</span>


<span class="k">def</span> <span class="nf">check_units</span><span class="p">(</span><span class="n">data_var</span><span class="p">:</span> <span class="n">DataArray</span><span class="p">,</span> <span class="n">default</span><span class="p">:</span> <span class="nb">float</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Check &quot;units&quot; attribute within a DataArray. Expect this to be a float</span>
<span class="sd">    or possible to convert to a float.</span>
<span class="sd">    If not present, use default value.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">attrs</span> <span class="o">=</span> <span class="n">data_var</span><span class="o">.</span><span class="n">attrs</span>
    <span class="k">if</span> <span class="s2">&quot;units&quot;</span> <span class="ow">in</span> <span class="n">attrs</span><span class="p">:</span>
        <span class="n">units_from_attrs</span> <span class="o">=</span> <span class="n">attrs</span><span class="p">[</span><span class="s2">&quot;units&quot;</span><span class="p">]</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">units_from_attrs</span><span class="p">,</span> <span class="nb">float</span><span class="p">):</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">units</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">units_from_attrs</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Cannot extract </span><span class="si">{</span><span class="n">units_from_attrs</span><span class="si">}</span><span class="s2"> value as float&quot;</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">units</span> <span class="o">=</span> <span class="n">default</span>

    <span class="k">return</span> <span class="n">units</span>


<span class="c1"># def footprints_data_merge(data: Union[dict, ObsData],</span>
<span class="c1">#                           domain: str,</span>
<span class="c1">#                           met_model: Optional[str] = None,</span>
<span class="c1">#                           load_flux: bool = True,</span>
<span class="c1">#                           load_bc: bool = True,</span>
<span class="c1">#                           calc_timeseries: bool = True,</span>
<span class="c1">#                           calc_bc: bool = True,</span>
<span class="c1">#                           HiTRes: bool = False,</span>
<span class="c1">#                           site_modifier: Dict[str, str] = {},</span>
<span class="c1">#                           height: Optional[str] = None,</span>
<span class="c1">#                           emissions_name: Optional[str] = None,</span>
<span class="c1">#                           fp_directory: Optional[Union[Path, str]] = None,</span>
<span class="c1">#                           flux_directory: Optional[Union[Path, str]] = None,</span>
<span class="c1">#                           bc_directory: Optional[Union[Path, str]] = None,</span>
<span class="c1">#                           resample_to_data: bool = False,</span>
<span class="c1">#                           species_footprint: Optional[str] = None,</span>
<span class="c1">#                           chunks: bool = False,</span>
<span class="c1">#                           verbose: bool = True,</span>
<span class="c1">#                           ) -&gt; Any:</span>
<span class="c1">#     &quot;&quot;&quot;</span>
<span class="c1">#     This will be a wrapper for footprints_data_merge function from acrg_name.name file written</span>
<span class="c1">#     &quot;&quot;&quot;</span>

<span class="c1">#     # Write this a wrapper for footprints_data_merge function from acrg_name.name file</span>

<span class="c1">#     print(&quot;The footprint_data_merge() wrapper function will be deprecated.&quot;)</span>
<span class="c1">#     print(&quot;Please use the ModelScenario class to set up your data&quot;)</span>
<span class="c1">#     print(&quot;Then call the model.footprints_data_merge() method e.g.&quot;)</span>
<span class="c1">#     print(&quot; model = ModelScenario(site, species, inlet, network, domain, ...)&quot;)</span>
<span class="c1">#     print(&quot; combined_data = model.footprints_data_merge()&quot;)</span>

<span class="c1">#     # resample_to_data --&gt; resample_to</span>
<span class="c1">#     # HiTRes --&gt; linked to species as co2</span>
<span class="c1">#     # directories --&gt; could link to adding new data to object store?</span>
<span class="c1">#     # height --&gt; inlet</span>
<span class="c1">#     # species_footprint --&gt; links to overall species?</span>
<span class="c1">#     # site_modifier --&gt; link to footprint name - different site name for footprint?</span>


<span class="c1"># Blueprint from Issue #42 created for this</span>

<span class="c1"># class LPDM():</span>

<span class="c1">#     def __init__(species, domain, flux, bc):</span>
<span class="c1">#         self.species=species</span>
<span class="c1">#         self.domain=domain</span>
<span class="c1">#         #etc...</span>

<span class="c1">#         self.flux=get_flux(species, domain, flux)</span>
<span class="c1">#         self.bc=get_bc(species, domain, bc)</span>

<span class="c1">#         # dictionary of obs datasets + footprints?</span>
<span class="c1">#         self.obs = {}</span>
<span class="c1">#         self.footprints = {}</span>

<span class="c1">#     def obs_get(self, site, average=None):</span>
<span class="c1">#         self.obs[&quot;site&quot;]=get_observations(self.species, site)</span>

<span class="c1">#     def obs_footprints_merge(self.obs, site, etc.):</span>
<span class="c1">#         obs_resampled, fp_resampled = footprints_data_merge(self.obs, site, kwargs_see_above)</span>
<span class="c1">#         self.obs[&quot;site&quot;] = obs_resampled</span>
<span class="c1">#         self.footprints[&quot;site&quot;] = fp_resampled</span>

<span class="c1">#     def model_mf(self, site):</span>
<span class="c1">#         # this is obviously not to be taken literally:</span>
<span class="c1">#         return self.footprints[&quot;site&quot;] * self.flux + self.bc</span>


<span class="c1"># if __name__ == &quot;__main__&quot;:</span>
<span class="c1">#     import LPDM # Need a better class name?</span>

<span class="c1">#     mod = LPDM(species=&quot;CH4&quot;, domain=&quot;EUROPE&quot;, flux=[&quot;ch4_source1&quot;, &quot;ch4_source2&quot;, &quot;ch4_source3&quot;],</span>
<span class="c1">#                         bc=&quot;CAMS&quot;)</span>

<span class="c1">#     for site in sites:</span>
<span class="c1">#         mod.obs_get(site, average=&quot;1H&quot;) # Need to be careful about averaging here and/or in fp/data merge step</span>
<span class="c1">#         mod.obs_footprints_merge(site, model=&quot;NAME-UKV&quot;, average=&quot;1D&quot;) # 1D average of combined fp/data dataset</span>

<span class="c1">#         # Optional</span>
<span class="c1">#         mod.get_site_met(site, met=&quot;ECMWF&quot;)</span>

<span class="c1">#     # output some obs</span>
<span class="c1">#     ds = mod.obs_out(site)</span>
<span class="c1">#     mod.obs_plot(site)</span>

<span class="c1">#     # plot some model output</span>
<span class="c1">#     mod.footprint_plot(site)</span>

<span class="c1">#     # predicted mole fraction</span>
<span class="c1">#     mf_mod = mod.model_mf(site, source=&quot;ch4_source1&quot;)</span>
</pre></div>

            </article>
            
            
            
            <footer class="bd-footer-article">
                <!-- Previous / next buttons -->
<div class='prev-next-area'>
</div>
            </footer>
            
          </div>
          
          
          
            <div class="bd-sidebar-secondary bd-toc">
              
<div class="toc-item">
  
<div id="searchbox"></div>
</div>

<div class="toc-item">
  
</div>

<div class="toc-item">
  
</div>

            </div>
          
          
        </div>
        <footer class="bd-footer-content">
          <div class="bd-footer-content__inner">
            
          </div>
        </footer>
        
      </main>
    </div>
  </div>

  
    
  <!-- Scripts loaded after <body> so the DOM is not blocked -->
  <script src="../../../_static/scripts/bootstrap.js?digest=796348d33e8b1d947c94"></script>
<script src="../../../_static/scripts/pydata-sphinx-theme.js?digest=796348d33e8b1d947c94"></script>

  <footer class="bd-footer"><div class="bd-footer__inner container">
  
  <div class="footer-item">
    
<p class="copyright">

    &copy; Copyright 2022 OpenGHG development team.<br>

</p>

  </div>
  
  <div class="footer-item">
    <p class="theme-version">
    Built with the
    <a href="https://pydata-sphinx-theme.readthedocs.io/en/stable/index.html">
        PyData Sphinx Theme
    </a>
    0.12.0.
</p>
  </div>
  
  <div class="footer-item">
    
  </div>
  
</div>
  </footer>
  </body>
</html>